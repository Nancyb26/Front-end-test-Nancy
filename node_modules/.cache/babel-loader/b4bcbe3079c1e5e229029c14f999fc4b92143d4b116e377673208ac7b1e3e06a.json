{"ast":null,"code":"import { jsx, jsxs, Fragment } from \"react/jsx-runtime\";\nimport React, { createElement } from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return arg => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return arg2 => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup(...args) {\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc(...procs) {\n  return () => {\n    procs.map(call);\n  };\n}\nfunction isDefined(arg) {\n  return arg !== void 0;\n}\nfunction noop() {}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, value => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach(subscription => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), stream2 => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), stream2 => connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n  return subscriber => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source, ...operators) {\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n  let current;\n  return done => next => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return done => value => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return done => compose(done, project);\n}\nfunction mapTo(value) {\n  return done => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return done => value => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return done => value => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue = null;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom(...sources) {\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return done => value => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge(...sources) {\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map(source => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source, comparator = defaultComparator) {\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n  const innerSubject = stream();\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor, dependencies = [], {\n  singleton\n} = {\n  singleton: true\n}) {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */new Map();\n  const _init = ({\n    id: id2,\n    constructor,\n    dependencies,\n    singleton\n  }) => {\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map(e => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$1 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = value => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const {\n      children,\n      ...props\n    } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), system22 => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$1(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$1(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    const RootComponent = Root;\n    return /* @__PURE__ */jsx(Context.Provider, {\n      value: system2,\n      children: Root ? /* @__PURE__ */jsx(RootComponent, {\n        ...omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n        children\n      }) : children\n    });\n  });\n  const usePublisher2 = key => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue18 = key => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const cb = React.useCallback(c => {\n      return subscribe(source, c);\n    }, [source]);\n    return React.useSyncExternalStore(cb, () => getValue(source), () => getValue(source));\n  };\n  const useEmitterValueLegacy = key => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$1(() => subscribe(source, next => {\n      if (next !== value) {\n        setValue(always(next));\n      }\n    }), [source, value]);\n    return value;\n  };\n  const useEmitterValue2 = React.version.startsWith(\"18\") ? useEmitterValue18 : useEmitterValueLegacy;\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$1(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nvar LogLevel = /* @__PURE__ */(LogLevel2 => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [0\n  /* DEBUG */]: \"debug\",\n  [1\n  /* INFO */]: \"log\",\n  [2\n  /* WARN */]: \"warn\",\n  [3\n  /* ERROR */]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(() => {\n  const logLevel = statefulStream(3\n  /* ERROR */);\n  const log = statefulStream((label, message, level = 1) => {\n    var _a;\n    const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n    if (level >= currentLevel) {\n      console[CONSOLE_METHOD_MAP[level]](\"%creact-virtuoso: %c%s %o\", \"color: #0253b3; font-weight: bold\", \"color: initial\", label, message);\n    }\n  });\n  return {\n    log,\n    logLevel\n  };\n}, [], {\n  singleton: true\n});\nfunction useSizeWithElRef(callback, enabled, skipAnimationFrame) {\n  const ref = React.useRef(null);\n  let callbackRef = _el => {};\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = React.useMemo(() => {\n      return new ResizeObserver(entries => {\n        const code = () => {\n          const element = entries[0].target;\n          if (element.offsetParent !== null) {\n            callback(element);\n          }\n        };\n        skipAnimationFrame ? code() : requestAnimationFrame(code);\n      });\n    }, [callback]);\n    callbackRef = elRef => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return {\n    ref,\n    callbackRef\n  };\n}\nfunction useSize(callback, enabled, skipAnimationFrame) {\n  return useSizeWithElRef(callback, enabled, skipAnimationFrame).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent, horizontalDirection, skipAnimationFrame) {\n  const memoedCallback = React.useCallback(el => {\n    const ranges = getChangedChildSizes(el.children, itemSize, horizontalDirection ? \"offsetWidth\" : \"offsetHeight\", log);\n    let scrollableElement = el.parentElement;\n    while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n      scrollableElement = scrollableElement.parentElement;\n    }\n    const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n    const scrollTop = customScrollParent ? horizontalDirection ? customScrollParent.scrollLeft : customScrollParent.scrollTop : windowScrolling ? horizontalDirection ? window.pageXOffset || document.documentElement.scrollLeft : window.pageYOffset || document.documentElement.scrollTop : horizontalDirection ? scrollableElement.scrollLeft : scrollableElement.scrollTop;\n    const scrollHeight = customScrollParent ? horizontalDirection ? customScrollParent.scrollWidth : customScrollParent.scrollHeight : windowScrolling ? horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight : horizontalDirection ? scrollableElement.scrollWidth : scrollableElement.scrollHeight;\n    const viewportHeight = customScrollParent ? horizontalDirection ? customScrollParent.offsetWidth : customScrollParent.offsetHeight : windowScrolling ? horizontalDirection ? window.innerWidth : window.innerHeight : horizontalDirection ? scrollableElement.offsetWidth : scrollableElement.offsetHeight;\n    scrollContainerStateCallback({\n      scrollTop: Math.max(scrollTop, 0),\n      scrollHeight,\n      viewportHeight\n    });\n    gap == null ? void 0 : gap(horizontalDirection ? resolveGapValue$1(\"column-gap\", getComputedStyle(el).columnGap, log) : resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n    if (ranges !== null) {\n      callback(ranges);\n    }\n  }, [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]);\n  return useSizeWithElRef(memoedCallback, enabled, skipAnimationFrame);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", {\n        child\n      }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({\n        startIndex: index,\n        endIndex: index,\n        size\n      });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent, horizontalDirection) {\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(ev => {\n    const el = ev.target;\n    const windowScroll = el === window || el === document;\n    const scrollTop = horizontalDirection ? windowScroll ? window.pageXOffset || document.documentElement.scrollLeft : el.scrollLeft : windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n    const scrollHeight = horizontalDirection ? windowScroll ? document.documentElement.scrollWidth : el.scrollWidth : windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n    const viewportHeight = horizontalDirection ? windowScroll ? window.innerWidth : el.offsetWidth : windowScroll ? window.innerHeight : el.offsetHeight;\n    const call2 = () => {\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n    };\n    if (ev.suppressFlushSync) {\n      call2();\n    } else {\n      ReactDOM.flushSync(call2);\n    }\n    if (scrollTopTarget.current !== null) {\n      if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n          timeoutRef.current = null;\n        }\n      }\n    }\n  }, [scrollContainerStateCallback, smoothScrollTargetReached]);\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({\n      target: localRef,\n      suppressFlushSync: true\n    });\n    localRef.addEventListener(\"scroll\", handler, {\n      passive: true\n    });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || (horizontalDirection ? \"offsetWidth\" in scrollerElement2 && scrollerElement2.offsetWidth === 0 : \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0)) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(correctItemSize(document.documentElement, horizontalDirection ? \"width\" : \"height\"), horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight);\n      offsetHeight = horizontalDirection ? window.innerWidth : window.innerHeight;\n      scrollTop = horizontalDirection ? document.documentElement.scrollLeft : document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2[horizontalDirection ? \"scrollWidth\" : \"scrollHeight\"];\n      offsetHeight = correctItemSize(scrollerElement2, horizontalDirection ? \"width\" : \"height\");\n      scrollTop = scrollerElement2[horizontalDirection ? \"scrollLeft\" : \"scrollTop\"];\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({\n        scrollTop,\n        scrollHeight,\n        viewportHeight: offsetHeight\n      });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    if (horizontalDirection) {\n      location = {\n        left: location.top,\n        behavior: location.behavior\n      };\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    if (horizontalDirection) {\n      location = {\n        left: location.top,\n        behavior: location.behavior\n      };\n    }\n    scrollerRef.current.scrollBy(location);\n  }\n  return {\n    scrollerRef,\n    scrollByCallback,\n    scrollToCallback\n  };\n}\nconst domIOSystem = system(() => {\n  const scrollContainerState = stream();\n  const scrollTop = stream();\n  const deviation = statefulStream(0);\n  const smoothScrollTargetReached = stream();\n  const statefulScrollTop = statefulStream(0);\n  const viewportHeight = stream();\n  const scrollHeight = stream();\n  const headerHeight = statefulStream(0);\n  const fixedHeaderHeight = statefulStream(0);\n  const fixedFooterHeight = statefulStream(0);\n  const footerHeight = statefulStream(0);\n  const scrollTo = stream();\n  const scrollBy = stream();\n  const scrollingInProgress = statefulStream(false);\n  const horizontalDirection = statefulStream(false);\n  const skipAnimationFrameInResizeObserver = statefulStream(false);\n  connect(pipe(scrollContainerState, map(({\n    scrollTop: scrollTop2\n  }) => scrollTop2)), scrollTop);\n  connect(pipe(scrollContainerState, map(({\n    scrollHeight: scrollHeight2\n  }) => scrollHeight2)), scrollHeight);\n  connect(scrollTop, statefulScrollTop);\n  return {\n    // input\n    scrollContainerState,\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight,\n    footerHeight,\n    scrollHeight,\n    smoothScrollTargetReached,\n    horizontalDirection,\n    skipAnimationFrameInResizeObserver,\n    // signals\n    scrollTo,\n    scrollBy,\n    // state\n    statefulScrollTop,\n    deviation,\n    scrollingInProgress\n  };\n}, [], {\n  singleton: true\n});\nconst NIL_NODE = {\n  lvl: 0\n};\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n  return {\n    k,\n    v,\n    lvl,\n    l,\n    r\n  };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node)) return NIL_NODE;\n  const {\n    k,\n    l,\n    r\n  } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, {\n        k: lastKey,\n        v: lastValue,\n        l: deleteLast(l)\n      }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, {\n      l: remove(l, key)\n    }));\n  } else {\n    return adjust(clone(node, {\n      r: remove(r, key)\n    }));\n  }\n}\nfunction find(node, key) {\n  if (empty(node)) {\n    return;\n  }\n  if (key === node.k) {\n    return node.v;\n  } else if (key < node.k) {\n    return find(node.l, key);\n  } else {\n    return find(node.r, key);\n  }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (Number(node[field]) === value) {\n    return [node.k, node.v];\n  }\n  if (Number(node[field]) < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, {\n      k,\n      v\n    });\n  } else if (k < node.k) {\n    return rebalance(clone(node, {\n      l: insert(node.l, k, v)\n    }));\n  } else {\n    return rebalance(clone(node, {\n      r: insert(node.r, k, v)\n    }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const {\n    k,\n    v,\n    l,\n    r\n  } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({\n      k,\n      v\n    });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), {\n    k: node.k,\n    v: node.v\n  }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, {\n    r: deleteLast(node.r)\n  }));\n}\nfunction clone(node, args) {\n  return newAANode(args.k !== void 0 ? args.k : node.k, args.v !== void 0 ? args.v : node.v, args.lvl !== void 0 ? args.lvl : node.lvl, args.l !== void 0 ? args.l : node.l, args.r !== void 0 ? args.r : node.r);\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const {\n    l,\n    r,\n    lvl\n  } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, {\n            r: l.r.l\n          }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, {\n            l: rl.r,\n            lvl: rlvl\n          })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let {\n    index: start,\n    value\n  } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const {\n      index: nextIndex,\n      value: nextValue\n    } = parser(items[i]);\n    result.push({\n      start,\n      end: nextIndex - 1,\n      value\n    });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({\n    start,\n    end: Infinity,\n    value\n  });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, ({\n    k: index,\n    v: value\n  }) => ({\n    index,\n    value\n  }));\n}\nfunction split(node) {\n  const {\n    r,\n    lvl\n  } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, {\n    l: clone(node, {\n      r: r.l\n    }),\n    lvl: lvl + 1\n  }) : node;\n}\nfunction skew(node) {\n  const {\n    l\n  } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, {\n    r: clone(node, {\n      l: l.r\n    })\n  }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(() => {\n  const recalcInProgress = statefulStream(false);\n  return {\n    recalcInProgress\n  };\n}, [], {\n  singleton: true\n});\nfunction rangeIncludes(refRange) {\n  const {\n    size,\n    startIndex,\n    endIndex\n  } = refRange;\n  return range => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n  let recognizedOffsetItems = 0;\n  let groupIndex = 0;\n  while (recognizedOffsetItems < offset) {\n    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n    groupIndex++;\n  }\n  const offsetIsExact = recognizedOffsetItems === offset;\n  return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const {\n      size,\n      startIndex,\n      endIndex\n    } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const {\n      start: rangeStart,\n      end: rangeEnd,\n      value: rangeValue\n    } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator({\n  index: itemIndex\n}, index) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({\n  offset: itemOffset\n}, offset) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return {\n    index: point.index,\n    value: point\n  };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const {\n    start: startIndex2,\n    value\n  } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const {\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastSize,\n    lastOffset\n  } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const {\n    offset,\n    index: startIndex,\n    size\n  } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n  return walk(sizeTree).map(({\n    k: startIndex,\n    v: size\n  }, index, sizeArray) => {\n    const nextSize = sizeArray[index + 1];\n    const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n    return {\n      startIndex,\n      endIndex,\n      size\n    };\n  });\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(([{\n  log\n}, {\n  recalcInProgress\n}]) => {\n  const sizeRanges = stream();\n  const totalCount = stream();\n  const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n  const unshiftWith = stream();\n  const shiftWith = stream();\n  const firstItemIndex = statefulStream(0);\n  const groupIndices = statefulStream([]);\n  const fixedItemSize = statefulStream(void 0);\n  const defaultItemSize = statefulStream(void 0);\n  const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n  const data = statefulStream(void 0);\n  const gap = statefulStream(0);\n  const initial = initialSizeState();\n  const sizes = statefulStreamFromEmitter(pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()), initial);\n  const prevGroupIndices = statefulStreamFromEmitter(pipe(groupIndices, distinctUntilChanged(), scan((prev, curr) => ({\n    prev: prev.current,\n    current: curr\n  }), {\n    prev: [],\n    current: []\n  }), map(({\n    prev\n  }) => prev)), []);\n  connect(pipe(groupIndices, filter(indexes => indexes.length > 0), withLatestFrom(sizes, gap), map(([groupIndices2, sizes2, gap2]) => {\n    const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n      return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n    }, newTree());\n    return {\n      ...sizes2,\n      groupIndices: groupIndices2,\n      groupOffsetTree\n    };\n  })), sizes);\n  connect(pipe(totalCount, withLatestFrom(sizes), filter(([totalCount2, {\n    lastIndex\n  }]) => {\n    return totalCount2 < lastIndex;\n  }), map(([totalCount2, {\n    lastIndex,\n    lastSize\n  }]) => {\n    return [{\n      startIndex: totalCount2,\n      endIndex: lastIndex,\n      size: lastSize\n    }];\n  })), sizeRanges);\n  connect(fixedItemSize, defaultItemSize);\n  const trackItemSizes = statefulStreamFromEmitter(pipe(fixedItemSize, map(size => size === void 0)), true);\n  connect(pipe(defaultItemSize, filter(value => {\n    return value !== void 0 && empty(getValue(sizes).sizeTree);\n  }), map(size => [{\n    startIndex: 0,\n    endIndex: 0,\n    size\n  }])), sizeRanges);\n  const listRefresh = streamFromEmitter(pipe(sizeRanges, withLatestFrom(sizes), scan(({\n    sizes: oldSizes\n  }, [_, newSizes]) => {\n    return {\n      changed: newSizes !== oldSizes,\n      sizes: newSizes\n    };\n  }, {\n    changed: false,\n    sizes: initial\n  }), map(value => value.changed)));\n  subscribe(pipe(firstItemIndex, scan((prev, next) => {\n    return {\n      diff: prev.prev - next,\n      prev: next\n    };\n  }, {\n    diff: 0,\n    prev: 0\n  }), map(val => val.diff)), offset => {\n    const {\n      groupIndices: groupIndices2\n    } = getValue(sizes);\n    if (offset > 0) {\n      publish(recalcInProgress, true);\n      publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n    } else if (offset < 0) {\n      const prevGroupIndicesValue = getValue(prevGroupIndices);\n      if (prevGroupIndicesValue.length > 0) {\n        offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n      }\n      publish(shiftWith, offset);\n    }\n  });\n  subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {\n    if (index < 0) {\n      log2(\"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\", {\n        firstItemIndex\n      }, LogLevel.ERROR);\n    }\n  });\n  const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n  connect(pipe(unshiftWith, withLatestFrom(sizes), map(([unshiftWith2, sizes2]) => {\n    const groupedMode = sizes2.groupIndices.length > 0;\n    const initialRanges = [];\n    const defaultSize = sizes2.lastSize;\n    if (groupedMode) {\n      const firstGroupSize = find(sizes2.sizeTree, 0);\n      let prependedGroupItemsCount = 0;\n      let groupIndex = 0;\n      while (prependedGroupItemsCount < unshiftWith2) {\n        const theGroupIndex = sizes2.groupIndices[groupIndex];\n        const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n        initialRanges.push({\n          startIndex: theGroupIndex,\n          endIndex: theGroupIndex,\n          size: firstGroupSize\n        });\n        initialRanges.push({\n          startIndex: theGroupIndex + 1,\n          endIndex: theGroupIndex + 1 + groupItemCount - 1,\n          size: defaultSize\n        });\n        groupIndex++;\n        prependedGroupItemsCount += groupItemCount + 1;\n      }\n      const sizeTreeKV = walk(sizes2.sizeTree);\n      const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n      if (firstGroupIsExpanded) {\n        sizeTreeKV.shift();\n      }\n      return sizeTreeKV.reduce((acc, {\n        k: index,\n        v: size\n      }) => {\n        let ranges = acc.ranges;\n        if (acc.prevSize !== 0) {\n          ranges = [...acc.ranges, {\n            startIndex: acc.prevIndex,\n            endIndex: index + unshiftWith2 - 1,\n            size: acc.prevSize\n          }];\n        }\n        return {\n          ranges,\n          prevIndex: index + unshiftWith2,\n          prevSize: size\n        };\n      }, {\n        ranges: initialRanges,\n        prevIndex: unshiftWith2,\n        prevSize: 0\n      }).ranges;\n    }\n    return walk(sizes2.sizeTree).reduce((acc, {\n      k: index,\n      v: size\n    }) => {\n      return {\n        ranges: [...acc.ranges, {\n          startIndex: acc.prevIndex,\n          endIndex: index + unshiftWith2 - 1,\n          size: acc.prevSize\n        }],\n        prevIndex: index + unshiftWith2,\n        prevSize: size\n      };\n    }, {\n      ranges: [],\n      prevIndex: 0,\n      prevSize: defaultSize\n    }).ranges;\n  })), sizeRanges);\n  const shiftWithOffset = streamFromEmitter(pipe(shiftWith, withLatestFrom(sizes, gap), map(([shiftWith2, {\n    offsetTree\n  }, gap2]) => {\n    const newFirstItemIndex = -shiftWith2;\n    return offsetOf(newFirstItemIndex, offsetTree, gap2);\n  })));\n  connect(pipe(shiftWith, withLatestFrom(sizes, gap), map(([shiftWith2, sizes2, gap2]) => {\n    const groupedMode = sizes2.groupIndices.length > 0;\n    if (groupedMode) {\n      if (empty(sizes2.sizeTree)) {\n        return sizes2;\n      }\n      let newSizeTree = newTree();\n      const prevGroupIndicesValue = getValue(prevGroupIndices);\n      let removedItemsCount = 0;\n      let groupIndex = 0;\n      let groupOffset = 0;\n      while (removedItemsCount < -shiftWith2) {\n        groupOffset = prevGroupIndicesValue[groupIndex];\n        const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n        groupIndex++;\n        removedItemsCount += groupItemCount + 1;\n      }\n      newSizeTree = walk(sizes2.sizeTree).reduce((acc, {\n        k,\n        v\n      }) => {\n        return insert(acc, Math.max(0, k + shiftWith2), v);\n      }, newSizeTree);\n      const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n      if (aGroupIsShrunk) {\n        const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n        newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n        const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n        newSizeTree = insert(newSizeTree, 1, nextItemSize);\n      }\n      return {\n        ...sizes2,\n        sizeTree: newSizeTree,\n        ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n      };\n    } else {\n      const newSizeTree = walk(sizes2.sizeTree).reduce((acc, {\n        k,\n        v\n      }) => {\n        return insert(acc, Math.max(0, k + shiftWith2), v);\n      }, newTree());\n      return {\n        ...sizes2,\n        sizeTree: newSizeTree,\n        ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n      };\n    }\n  })), sizes);\n  return {\n    // input\n    data,\n    totalCount,\n    sizeRanges,\n    groupIndices,\n    defaultItemSize,\n    fixedItemSize,\n    unshiftWith,\n    shiftWith,\n    shiftWithOffset,\n    beforeUnshiftWith,\n    firstItemIndex,\n    gap,\n    // output\n    sizes,\n    listRefresh,\n    statefulTotalCount,\n    trackItemSizes,\n    itemSize\n  };\n}, tup(loggerSystem, recalcSystem), {\n  singleton: true\n});\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? {\n    index: location\n  } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(([{\n  sizes,\n  totalCount,\n  listRefresh,\n  gap\n}, {\n  scrollingInProgress,\n  viewportHeight,\n  scrollTo,\n  smoothScrollTargetReached,\n  headerHeight,\n  footerHeight,\n  fixedHeaderHeight,\n  fixedFooterHeight\n}, {\n  log\n}]) => {\n  const scrollToIndex = stream();\n  const scrollTargetReached = stream();\n  const topListHeight = statefulStream(0);\n  let unsubscribeNextListRefresh = null;\n  let cleartTimeoutRef = null;\n  let unsubscribeListRefresh = null;\n  function cleanup() {\n    if (unsubscribeNextListRefresh) {\n      unsubscribeNextListRefresh();\n      unsubscribeNextListRefresh = null;\n    }\n    if (unsubscribeListRefresh) {\n      unsubscribeListRefresh();\n      unsubscribeListRefresh = null;\n    }\n    if (cleartTimeoutRef) {\n      clearTimeout(cleartTimeoutRef);\n      cleartTimeoutRef = null;\n    }\n    publish(scrollingInProgress, false);\n  }\n  connect(pipe(scrollToIndex, withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log), withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight), map(([[location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2], gap2, fixedHeaderHeight2, fixedFooterHeight2]) => {\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    const lastIndex = totalCount2 - 1;\n    const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n    let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n    if (align === \"end\") {\n      top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n      if (index === lastIndex) {\n        top += footerHeight2;\n      }\n    } else if (align === \"center\") {\n      top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n    } else {\n      top -= topListHeight2;\n    }\n    if (offset) {\n      top += offset;\n    }\n    const retry = listChanged => {\n      cleanup();\n      if (listChanged) {\n        log2(\"retrying to scroll to\", {\n          location\n        }, LogLevel.DEBUG);\n        publish(scrollToIndex, location);\n      } else {\n        publish(scrollTargetReached, true);\n        log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n      }\n    };\n    cleanup();\n    if (behavior === \"smooth\") {\n      let listChanged = false;\n      unsubscribeListRefresh = subscribe(listRefresh, changed => {\n        listChanged = listChanged || changed;\n      });\n      unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n        retry(listChanged);\n      });\n    } else {\n      unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n    }\n    cleartTimeoutRef = setTimeout(() => {\n      cleanup();\n    }, 1200);\n    publish(scrollingInProgress, true);\n    log2(\"scrolling from index to\", {\n      index,\n      top,\n      behavior\n    }, LogLevel.DEBUG);\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  return {\n    scrollToIndex,\n    scrollTargetReached,\n    topListHeight\n  };\n}, tup(sizeSystem, domIOSystem, loggerSystem), {\n  singleton: true\n});\nfunction watchChangesFor(limit) {\n  return done => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return value => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{\n  scrollContainerState,\n  scrollTop,\n  viewportHeight,\n  headerHeight,\n  footerHeight,\n  scrollBy\n}]) => {\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(pipe(merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))), distinctUntilChanged()), false);\n  const isScrollingBy = statefulStreamFromEmitter(pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()), false);\n  connect(pipe(combineLatest(duc(scrollTop), duc(atTopThreshold)), map(([top, atTopThreshold2]) => top <= atTopThreshold2), distinctUntilChanged()), isAtTop);\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(pipe(combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)), scan((current, [{\n    scrollTop: scrollTop2,\n    scrollHeight\n  }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {\n    const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n    const state = {\n      viewportHeight: viewportHeight2,\n      scrollTop: scrollTop2,\n      scrollHeight\n    };\n    if (isAtBottom2) {\n      let atBottomBecause;\n      let scrollTopDelta;\n      if (scrollTop2 > current.state.scrollTop) {\n        atBottomBecause = \"SCROLLED_DOWN\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2;\n      } else {\n        atBottomBecause = \"SIZE_DECREASED\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n      }\n      return {\n        atBottom: true,\n        state,\n        atBottomBecause,\n        scrollTopDelta\n      };\n    }\n    let notAtBottomBecause;\n    if (state.scrollHeight > current.state.scrollHeight) {\n      notAtBottomBecause = \"SIZE_INCREASED\";\n    } else if (viewportHeight2 < current.state.viewportHeight) {\n      notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n    } else if (scrollTop2 < current.state.scrollTop) {\n      notAtBottomBecause = \"SCROLLING_UPWARDS\";\n    } else {\n      notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n    }\n    return {\n      atBottom: false,\n      notAtBottomBecause,\n      state\n    };\n  }, INITIAL_BOTTOM_STATE), distinctUntilChanged((prev, next) => {\n    return prev && prev.atBottom === next.atBottom;\n  })));\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(pipe(scrollContainerState, scan((current, {\n    scrollTop: scrollTop2,\n    scrollHeight,\n    viewportHeight: viewportHeight2\n  }) => {\n    if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n      const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n      if (current.scrollTop !== scrollTop2 && atBottom) {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: current.scrollTop - scrollTop2,\n          changed: true\n        };\n      } else {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: 0,\n          changed: true\n        };\n      }\n    } else {\n      return {\n        scrollTop: scrollTop2,\n        scrollHeight,\n        jump: 0,\n        changed: false\n      };\n    }\n  }, {\n    scrollHeight: 0,\n    jump: 0,\n    scrollTop: 0,\n    changed: false\n  }), filter(value => value.changed), map(value => value.jump)), 0);\n  connect(pipe(atBottomState, map(state => state.atBottom)), isAtBottom);\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(pipe(scrollContainerState, map(({\n    scrollTop: scrollTop2\n  }) => scrollTop2), distinctUntilChanged(), scan((acc, scrollTop2) => {\n    if (getValue(isScrollingBy)) {\n      return {\n        direction: acc.direction,\n        prevScrollTop: scrollTop2\n      };\n    }\n    return {\n      direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN,\n      prevScrollTop: scrollTop2\n    };\n  }, {\n    direction: DOWN,\n    prevScrollTop: 0\n  }), map(value => value.direction)), scrollDirection);\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(pipe(isScrolling, filter(value => !value),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  mapTo(0)), scrollVelocity);\n  connect(pipe(scrollTop, throttleTime(100), withLatestFrom(isScrolling), filter(([_, isScrolling2]) => !!isScrolling2), scan(([_, prev], [next]) => [prev, next], [0, 0]), map(([prev, next]) => next - prev)), scrollVelocity);\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(([{\n  log\n}]) => {\n  const propsReady = statefulStream(false);\n  const didMount = streamFromEmitter(pipe(propsReady, filter(ready => ready), distinctUntilChanged()));\n  subscribe(propsReady, value => {\n    value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n  });\n  return {\n    propsReady,\n    didMount\n  };\n}, tup(loggerSystem), {\n  singleton: true\n});\nfunction skipFrames(frameCount, callback) {\n  if (frameCount == 0) {\n    callback();\n  } else {\n    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));\n  }\n}\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nconst initialTopMostItemIndexSystem = system(([{\n  sizes,\n  listRefresh,\n  defaultItemSize\n}, {\n  scrollTop\n}, {\n  scrollToIndex,\n  scrollTargetReached\n}, {\n  didMount\n}]) => {\n  const scrolledToInitialItem = statefulStream(true);\n  const initialTopMostItemIndex = statefulStream(0);\n  const initialItemFinalLocationReached = statefulStream(true);\n  connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location), mapTo(false)), scrolledToInitialItem);\n  connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location), mapTo(false)), initialItemFinalLocationReached);\n  subscribe(pipe(combineLatest(listRefresh, didMount), withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, initialItemFinalLocationReached), filter(([[, didMount2], scrolledToInitialItem2, {\n    sizeTree\n  }, defaultItemSize2, scrollScheduled]) => {\n    return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled;\n  }), withLatestFrom(initialTopMostItemIndex)), ([, initialTopMostItemIndex2]) => {\n    handleNext(scrollTargetReached, () => {\n      publish(initialItemFinalLocationReached, true);\n    });\n    skipFrames(4, () => {\n      handleNext(scrollTop, () => {\n        publish(scrolledToInitialItem, true);\n      });\n      publish(scrollToIndex, initialTopMostItemIndex2);\n    });\n  });\n  return {\n    scrolledToInitialItem,\n    initialTopMostItemIndex,\n    initialItemFinalLocationReached\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem), {\n  singleton: true\n});\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(([{\n  totalCount,\n  listRefresh\n}, {\n  isAtBottom,\n  atBottomState\n}, {\n  scrollToIndex\n}, {\n  scrolledToInitialItem\n}, {\n  propsReady,\n  didMount\n}, {\n  log\n}, {\n  scrollingInProgress\n}]) => {\n  const followOutput = statefulStream(false);\n  const autoscrollToBottom = stream();\n  let pendingScrollHandle = null;\n  function scrollToBottom(followOutputBehavior) {\n    publish(scrollToIndex, {\n      index: \"LAST\",\n      align: \"end\",\n      behavior: followOutputBehavior\n    });\n  }\n  subscribe(pipe(combineLatest(pipe(duc(totalCount), skip(1)), didMount), withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress), map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {\n    let shouldFollow = didMount2 && scrolledToInitialItem2;\n    let followOutputBehavior = \"auto\";\n    if (shouldFollow) {\n      followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n      shouldFollow = shouldFollow && !!followOutputBehavior;\n    }\n    return {\n      totalCount: totalCount2,\n      shouldFollow,\n      followOutputBehavior\n    };\n  }), filter(({\n    shouldFollow\n  }) => shouldFollow)), ({\n    totalCount: totalCount2,\n    followOutputBehavior\n  }) => {\n    if (pendingScrollHandle) {\n      pendingScrollHandle();\n      pendingScrollHandle = null;\n    }\n    pendingScrollHandle = handleNext(listRefresh, () => {\n      getValue(log)(\"following output to \", {\n        totalCount: totalCount2\n      }, LogLevel.DEBUG);\n      scrollToBottom(followOutputBehavior);\n      pendingScrollHandle = null;\n    });\n  });\n  function trapNextSizeIncrease(followOutput2) {\n    const cancel = handleNext(atBottomState, state => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n        getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n        scrollToBottom(\"auto\");\n      }\n    });\n    setTimeout(cancel, 100);\n  }\n  subscribe(pipe(combineLatest(duc(followOutput), totalCount, propsReady), filter(([follow,, ready]) => follow && ready), scan(({\n    value\n  }, [, next]) => {\n    return {\n      refreshed: value === next,\n      value: next\n    };\n  }, {\n    refreshed: false,\n    value: 0\n  }), filter(({\n    refreshed\n  }) => refreshed), withLatestFrom(followOutput, totalCount)), ([, followOutput2]) => {\n    if (getValue(scrolledToInitialItem)) {\n      trapNextSizeIncrease(followOutput2 !== false);\n    }\n  });\n  subscribe(autoscrollToBottom, () => {\n    trapNextSizeIncrease(getValue(followOutput) !== false);\n  });\n  subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {\n    if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n      scrollToBottom(\"auto\");\n    }\n  });\n  return {\n    followOutput,\n    autoscrollToBottom\n  };\n}, tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem));\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce((acc, groupCount) => {\n    acc.groupIndices.push(acc.totalCount);\n    acc.totalCount += groupCount + 1;\n    return acc;\n  }, {\n    totalCount: 0,\n    groupIndices: []\n  });\n}\nconst groupedListSystem = system(([{\n  totalCount,\n  groupIndices,\n  sizes\n}, {\n  scrollTop,\n  headerHeight\n}]) => {\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(pipe(groupIndicesAndCount, map(value => value.totalCount)), totalCount);\n  connect(pipe(groupIndicesAndCount, map(value => value.groupIndices)), groupIndices);\n  connect(pipe(combineLatest(scrollTop, sizes, headerHeight), filter(([_, sizes2]) => hasGroups(sizes2)), map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]), distinctUntilChanged(), map(index => [index])), topItemsIndexes);\n  return {\n    groupCounts,\n    topItemsIndexes\n  };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(([{\n  scrollTop,\n  viewportHeight,\n  deviation,\n  headerHeight,\n  fixedHeaderHeight\n}]) => {\n  const listBoundary = stream();\n  const topListHeight = statefulStream(0);\n  const increaseViewportBy = statefulStream(0);\n  const overscan = statefulStream(0);\n  const visibleRange = statefulStreamFromEmitter(pipe(combineLatest(duc(scrollTop), duc(viewportHeight), duc(headerHeight), duc(listBoundary, tupleComparator), duc(overscan), duc(topListHeight), duc(fixedHeaderHeight), duc(deviation), duc(increaseViewportBy)), map(([scrollTop2, viewportHeight2, headerHeight2, [listTop, listBottom], overscan2, topListHeight2, fixedHeaderHeight2, deviation2, increaseViewportBy2]) => {\n    const top = scrollTop2 - deviation2;\n    const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n    const headerVisible = Math.max(headerHeight2 - top, 0);\n    let direction = NONE;\n    const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n    const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n    listTop -= deviation2;\n    listTop += headerHeight2 + fixedHeaderHeight2;\n    listBottom += headerHeight2 + fixedHeaderHeight2;\n    listBottom -= deviation2;\n    if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n      direction = UP;\n    }\n    if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n      direction = DOWN;\n    }\n    if (direction !== NONE) {\n      return [Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0), top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition];\n    }\n    return null;\n  }), filter(value => value != null), distinctUntilChanged(tupleComparator)), [0, 0]);\n  return {\n    // input\n    listBoundary,\n    overscan,\n    topListHeight,\n    increaseViewportBy,\n    // output\n    visibleRange\n  };\n}, tup(domIOSystem), {\n  singleton: true\n});\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [{\n      index: groupIndex,\n      size: 0,\n      offset: 0\n    }, {\n      index: itemIndex,\n      size: 0,\n      offset: 0,\n      data: data && data[0]\n    }];\n  }\n  return [{\n    index,\n    size: 0,\n    offset: 0,\n    data: data && data[0]\n  }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map(item => ({\n      ...item,\n      index: item.index + firstItemIndex,\n      originalIndex: item.index\n    }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const {\n    lastSize,\n    lastOffset,\n    lastIndex\n  } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nfunction buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap, data) {\n  let includedGroupsCount = 0;\n  if (sizes.groupIndices.length > 0) {\n    for (const index of sizes.groupIndices) {\n      if (index - includedGroupsCount >= itemCount) {\n        break;\n      }\n      includedGroupsCount++;\n    }\n  }\n  const adjustedCount = itemCount + includedGroupsCount;\n  const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);\n  const items = Array.from({\n    length: adjustedCount\n  }).map((_, index) => ({\n    index: index + initialTopMostItemIndexNumber,\n    size: 0,\n    offset: 0,\n    data: data[index + initialTopMostItemIndexNumber]\n  }));\n  return buildListState(items, [], adjustedCount, gap, sizes, firstItemIndex);\n}\nconst listStateSystem = system(([{\n  sizes,\n  totalCount,\n  data,\n  firstItemIndex,\n  gap\n}, groupedListSystem2, {\n  visibleRange,\n  listBoundary,\n  topListHeight: rangeTopListHeight\n}, {\n  scrolledToInitialItem,\n  initialTopMostItemIndex\n}, {\n  topListHeight\n}, stateFlags, {\n  didMount\n}, {\n  recalcInProgress\n}]) => {\n  const topItemsIndexes = statefulStream([]);\n  const initialItemCount = statefulStream(0);\n  const itemsRendered = stream();\n  connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n  const listState = statefulStreamFromEmitter(pipe(combineLatest(didMount, recalcInProgress, duc(visibleRange, tupleComparator), duc(totalCount), duc(sizes), duc(initialTopMostItemIndex), scrolledToInitialItem, duc(topItemsIndexes), duc(firstItemIndex), duc(gap), data), filter(([mount, recalcInProgress2,, totalCount2,,,,,,, data2]) => {\n    const dataChangeInProgress = data2 && data2.length !== totalCount2;\n    return mount && !recalcInProgress2 && !dataChangeInProgress;\n  }), map(([,, [startOffset, endOffset], totalCount2, sizes2, initialTopMostItemIndex2, scrolledToInitialItem2, topItemsIndexes2, firstItemIndex2, gap2, data2]) => {\n    const sizesValue = sizes2;\n    const {\n      sizeTree,\n      offsetTree\n    } = sizesValue;\n    const initialItemCountValue = getValue(initialItemCount);\n    if (totalCount2 === 0) {\n      return {\n        ...EMPTY_LIST_STATE,\n        totalCount: totalCount2\n      };\n    }\n    if (startOffset === 0 && endOffset === 0) {\n      if (initialItemCountValue === 0) {\n        return {\n          ...EMPTY_LIST_STATE,\n          totalCount: totalCount2\n        };\n      } else {\n        return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap2, data2 || []);\n      }\n    }\n    if (empty(sizeTree)) {\n      if (initialItemCountValue > 0) {\n        return null;\n      }\n      const state = buildListState(probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2), [], totalCount2, gap2, sizesValue, firstItemIndex2);\n      return state;\n    }\n    const topItems = [];\n    if (topItemsIndexes2.length > 0) {\n      const startIndex = topItemsIndexes2[0];\n      const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n      let offset = 0;\n      for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n        const size = range.value;\n        const rangeStartIndex = Math.max(range.start, startIndex);\n        const rangeEndIndex = Math.min(range.end, endIndex);\n        for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n          topItems.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size;\n        }\n      }\n    }\n    if (!scrolledToInitialItem2) {\n      return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n    }\n    const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n    const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n    if (offsetPointRanges.length === 0) {\n      return null;\n    }\n    const maxIndex = totalCount2 - 1;\n    const items = tap([], result => {\n      for (const range of offsetPointRanges) {\n        const point = range.value;\n        let offset = point.offset;\n        let rangeStartIndex = range.start;\n        const size = point.size;\n        if (point.offset < startOffset) {\n          rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n          const itemCount = rangeStartIndex - range.start;\n          offset += itemCount * size + itemCount * gap2;\n        }\n        if (rangeStartIndex < minStartIndex) {\n          offset += (minStartIndex - rangeStartIndex) * size;\n          rangeStartIndex = minStartIndex;\n        }\n        const endIndex = Math.min(range.end, maxIndex);\n        for (let i = rangeStartIndex; i <= endIndex; i++) {\n          if (offset >= endOffset) {\n            break;\n          }\n          result.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size + gap2;\n        }\n      }\n    });\n    return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n  }),\n  //@ts-expect-error filter needs to be fixed\n  filter(value => value !== null), distinctUntilChanged()), EMPTY_LIST_STATE);\n  connect(pipe(data, filter(isDefined), map(data2 => data2 == null ? void 0 : data2.length)), totalCount);\n  connect(pipe(listState, map(value => value.topListHeight)), topListHeight);\n  connect(topListHeight, rangeTopListHeight);\n  connect(pipe(listState, map(state => [state.top, state.bottom])), listBoundary);\n  connect(pipe(listState, map(state => state.items)), itemsRendered);\n  const endReached = streamFromEmitter(pipe(listState, filter(({\n    items\n  }) => items.length > 0), withLatestFrom(totalCount, data), filter(([{\n    items\n  }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1), map(([, totalCount2, data2]) => [totalCount2 - 1, data2]), distinctUntilChanged(tupleComparator), map(([count]) => count)));\n  const startReached = streamFromEmitter(pipe(listState, throttleTime(200), filter(({\n    items,\n    topItems\n  }) => {\n    return items.length > 0 && items[0].originalIndex === topItems.length;\n  }), map(({\n    items\n  }) => items[0].index), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(listState, filter(({\n    items\n  }) => items.length > 0), map(({\n    items\n  }) => {\n    let startIndex = 0;\n    let endIndex = items.length - 1;\n    while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n      startIndex++;\n    }\n    while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n      endIndex--;\n    }\n    return {\n      startIndex: items[startIndex].index,\n      endIndex: items[endIndex].index\n    };\n  }), distinctUntilChanged(rangeComparator)));\n  return {\n    listState,\n    topItemsIndexes,\n    endReached,\n    startReached,\n    rangeChanged,\n    itemsRendered,\n    initialItemCount,\n    ...stateFlags\n  };\n}, tup(sizeSystem, groupedListSystem, sizeRangeSystem, initialTopMostItemIndexSystem, scrollToIndexSystem, stateFlagsSystem, propsReadySystem, recalcSystem), {\n  singleton: true\n});\nconst initialItemCountSystem = system(([{\n  sizes,\n  firstItemIndex,\n  data,\n  gap\n}, {\n  initialTopMostItemIndex\n}, {\n  initialItemCount,\n  listState\n}, {\n  didMount\n}]) => {\n  connect(pipe(didMount, withLatestFrom(initialItemCount), filter(([, count]) => count !== 0), withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap, data), map(([[, count], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2 = []]) => {\n    return buildListStateFromItemCount(count, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2);\n  })), listState);\n  return {};\n}, tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem), {\n  singleton: true\n});\nconst scrollSeekSystem = system(([{\n  scrollVelocity\n}]) => {\n  const isSeeking = statefulStream(false);\n  const rangeChanged = stream();\n  const scrollSeekConfiguration = statefulStream(false);\n  connect(pipe(scrollVelocity, withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged), filter(([_, config]) => !!config), map(([speed, config, isSeeking2, range]) => {\n    const {\n      exit,\n      enter\n    } = config;\n    if (isSeeking2) {\n      if (exit(speed, range)) {\n        return false;\n      }\n    } else {\n      if (enter(speed, range)) {\n        return true;\n      }\n    }\n    return isSeeking2;\n  }), distinctUntilChanged()), isSeeking);\n  subscribe(pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)), ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range));\n  return {\n    isSeeking,\n    scrollSeekConfiguration,\n    scrollVelocity,\n    scrollSeekRangeChanged: rangeChanged\n  };\n}, tup(stateFlagsSystem), {\n  singleton: true\n});\nconst topItemCountSystem = system(([{\n  topItemsIndexes\n}]) => {\n  const topItemCount = statefulStream(0);\n  connect(pipe(topItemCount, filter(length => length >= 0), map(length => Array.from({\n    length\n  }).map((_, index) => index))), topItemsIndexes);\n  return {\n    topItemCount\n  };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(([{\n  footerHeight,\n  headerHeight,\n  fixedHeaderHeight,\n  fixedFooterHeight\n}, {\n  listState\n}]) => {\n  const totalListHeightChanged = stream();\n  const totalListHeight = statefulStreamFromEmitter(pipe(combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState), map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {\n    return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n  })), 0);\n  connect(duc(totalListHeight), totalListHeightChanged);\n  return {\n    totalListHeight,\n    totalListHeightChanged\n  };\n}, tup(domIOSystem, listStateSystem), {\n  singleton: true\n});\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(([{\n  scrollBy,\n  scrollTop,\n  deviation,\n  scrollingInProgress\n}, {\n  isScrolling,\n  isAtBottom,\n  scrollDirection,\n  lastJumpDueToItemResize\n}, {\n  listState\n}, {\n  beforeUnshiftWith,\n  shiftWithOffset,\n  sizes,\n  gap\n}, {\n  log\n}, {\n  recalcInProgress\n}]) => {\n  const deviationOffset = streamFromEmitter(pipe(listState, withLatestFrom(lastJumpDueToItemResize), scan(([, prevItems, prevTotalCount, prevTotalHeight], [{\n    items,\n    totalCount,\n    bottom,\n    offsetBottom\n  }, lastJumpDueToItemResize2]) => {\n    const totalHeight = bottom + offsetBottom;\n    let newDev = 0;\n    if (prevTotalCount === totalCount) {\n      if (prevItems.length > 0 && items.length > 0) {\n        const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n        if (!atStart) {\n          newDev = totalHeight - prevTotalHeight;\n          if (newDev !== 0) {\n            newDev += lastJumpDueToItemResize2;\n          }\n        }\n      }\n    }\n    return [newDev, items, totalCount, totalHeight];\n  }, [0, [], 0, 0]), filter(([amount]) => amount !== 0), withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress), filter(([, scrollTop2, scrollDirection2, scrollingInProgress2,,, recalcInProgress2]) => {\n    return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n  }), map(([[amount],,,,, log2]) => {\n    log2(\"Upward scrolling compensation\", {\n      amount\n    }, LogLevel.DEBUG);\n    return amount;\n  })));\n  function scrollByWith(offset) {\n    if (offset > 0) {\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n      publish(deviation, 0);\n    } else {\n      publish(deviation, 0);\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n    }\n  }\n  subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {\n    if (isScrolling2 && isMobileSafari()) {\n      publish(deviation, deviationAmount - offset);\n    } else {\n      scrollByWith(-offset);\n    }\n  });\n  subscribe(pipe(combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress), filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0), map(([_, deviation2]) => deviation2), throttleTime(1)), scrollByWith);\n  connect(pipe(shiftWithOffset, map(offset => {\n    return {\n      top: -offset\n    };\n  })), scrollBy);\n  subscribe(pipe(beforeUnshiftWith, withLatestFrom(sizes, gap), map(([offset, {\n    lastSize: defaultItemSize,\n    groupIndices,\n    sizeTree\n  }, gap2]) => {\n    function getItemOffset(itemCount) {\n      return itemCount * (defaultItemSize + gap2);\n    }\n    if (groupIndices.length === 0) {\n      return getItemOffset(offset);\n    } else {\n      let amount = 0;\n      const defaultGroupSize = find(sizeTree, 0);\n      let recognizedOffsetItems = 0;\n      let groupIndex = 0;\n      while (recognizedOffsetItems < offset) {\n        recognizedOffsetItems++;\n        amount += defaultGroupSize;\n        let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n        if (recognizedOffsetItems + groupItemCount > offset) {\n          amount -= defaultGroupSize;\n          groupItemCount = offset - recognizedOffsetItems + 1;\n        }\n        recognizedOffsetItems += groupItemCount;\n        amount += getItemOffset(groupItemCount);\n        groupIndex++;\n      }\n      return amount;\n    }\n  })), offset => {\n    publish(deviation, offset);\n    requestAnimationFrame(() => {\n      publish(scrollBy, {\n        top: offset\n      });\n      requestAnimationFrame(() => {\n        publish(deviation, 0);\n        publish(recalcInProgress, false);\n      });\n    });\n  });\n  return {\n    deviation\n  };\n}, tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem));\nconst initialScrollTopSystem = system(([{\n  didMount\n}, {\n  scrollTo\n}, {\n  listState\n}]) => {\n  const initialScrollTop = statefulStream(0);\n  subscribe(pipe(didMount, withLatestFrom(initialScrollTop), filter(([, offset]) => offset !== 0), map(([, offset]) => ({\n    top: offset\n  }))), location => {\n    handleNext(pipe(listState, skip(1), filter(state => state.items.length > 1)), () => {\n      requestAnimationFrame(() => {\n        publish(scrollTo, location);\n      });\n    });\n  });\n  return {\n    initialScrollTop\n  };\n}, tup(propsReadySystem, domIOSystem, listStateSystem), {\n  singleton: true\n});\nconst alignToBottomSystem = system(([{\n  viewportHeight\n}, {\n  totalListHeight\n}]) => {\n  const alignToBottom = statefulStream(false);\n  const paddingTopAddition = statefulStreamFromEmitter(pipe(combineLatest(alignToBottom, viewportHeight, totalListHeight), filter(([enabled]) => enabled), map(([, viewportHeight2, totalListHeight2]) => {\n    return Math.max(0, viewportHeight2 - totalListHeight2);\n  }), throttleTime(0), distinctUntilChanged()), 0);\n  return {\n    alignToBottom,\n    paddingTopAddition\n  };\n}, tup(domIOSystem, totalListHeightSystem), {\n  singleton: true\n});\nconst windowScrollerSystem = system(([{\n  scrollTo,\n  scrollContainerState\n}]) => {\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(pipe(combineLatest(windowScrollContainerState, windowViewportRect), map(([{\n    viewportHeight,\n    scrollTop: windowScrollTop,\n    scrollHeight\n  }, {\n    offsetTop\n  }]) => {\n    return {\n      scrollTop: Math.max(0, windowScrollTop - offsetTop),\n      scrollHeight,\n      viewportHeight\n    };\n  })), scrollContainerState);\n  connect(pipe(scrollTo, withLatestFrom(windowViewportRect), map(([scrollTo2, {\n    offsetTop\n  }]) => {\n    return {\n      ...scrollTo2,\n      top: scrollTo2.top + offsetTop\n    };\n  })), windowScrollTo);\n  return {\n    // config\n    useWindowScroll,\n    customScrollParent,\n    // input\n    windowScrollContainerState,\n    windowViewportRect,\n    // signals\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = ({\n  itemTop: itemTop2,\n  itemBottom,\n  viewportTop,\n  viewportBottom,\n  locationParams: {\n    behavior,\n    align,\n    ...rest\n  }\n}) => {\n  if (itemTop2 < viewportTop) {\n    return {\n      ...rest,\n      behavior,\n      align: align != null ? align : \"start\"\n    };\n  }\n  if (itemBottom > viewportBottom) {\n    return {\n      ...rest,\n      behavior,\n      align: align != null ? align : \"end\"\n    };\n  }\n  return null;\n};\nconst scrollIntoViewSystem = system(([{\n  sizes,\n  totalCount,\n  gap\n}, {\n  scrollTop,\n  viewportHeight,\n  headerHeight,\n  fixedHeaderHeight,\n  fixedFooterHeight,\n  scrollingInProgress\n}, {\n  scrollToIndex\n}]) => {\n  const scrollIntoView = stream();\n  connect(pipe(scrollIntoView, withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop), withLatestFrom(gap), map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {\n    const {\n      done,\n      behavior,\n      align,\n      calculateViewLocation = defaultCalculateViewLocation,\n      ...rest\n    } = viewLocation;\n    const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n    const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n    const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n    const viewportTop = scrollTop2 + fixedHeaderHeight2;\n    const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n    const location = calculateViewLocation({\n      itemTop: itemTop2,\n      itemBottom,\n      viewportTop,\n      viewportBottom,\n      locationParams: {\n        behavior,\n        align,\n        ...rest\n      }\n    });\n    if (location) {\n      done && handleNext(pipe(scrollingInProgress, filter(value => value === false),\n      // skips the initial publish of false, and the cleanup call.\n      // but if scrollingInProgress is true, we skip the initial publish.\n      skip(getValue(scrollingInProgress) ? 1 : 2)), done);\n    } else {\n      done && done();\n    }\n    return location;\n  }), filter(value => value !== null)), scrollToIndex);\n  return {\n    scrollIntoView\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem), {\n  singleton: true\n});\nconst stateLoadSystem = system(([{\n  sizes,\n  sizeRanges\n}, {\n  scrollTop,\n  headerHeight\n}, {\n  initialTopMostItemIndex\n}, {\n  didMount\n}, {\n  useWindowScroll,\n  windowScrollContainerState,\n  windowViewportRect\n}]) => {\n  const getState = stream();\n  const restoreStateFrom = statefulStream(void 0);\n  const statefulWindowScrollContainerState = statefulStream(null);\n  const statefulWindowViewportRect = statefulStream(null);\n  connect(windowScrollContainerState, statefulWindowScrollContainerState);\n  connect(windowViewportRect, statefulWindowViewportRect);\n  subscribe(pipe(getState, withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect, headerHeight)), ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2, headerHeight2]) => {\n    const ranges = sizeTreeToRanges(sizes2.sizeTree);\n    if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {\n      scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;\n    }\n    scrollTop2 -= headerHeight2;\n    callback({\n      ranges,\n      scrollTop: scrollTop2\n    });\n  });\n  connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n  connect(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, state]) => state !== void 0), distinctUntilChanged(), map(([, snapshot]) => {\n    return snapshot.ranges;\n  })), sizeRanges);\n  return {\n    getState,\n    restoreStateFrom\n  };\n}, tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem));\nfunction locationFromSnapshot(snapshot) {\n  return {\n    offset: snapshot.scrollTop,\n    index: 0,\n    align: \"start\"\n  };\n}\nconst featureGroup1System = system(([sizeRange, initialItemCount, propsReady, scrollSeek, totalListHeight, initialScrollTopSystem2, alignToBottom, windowScroller, scrollIntoView, logger]) => {\n  return {\n    ...sizeRange,\n    ...initialItemCount,\n    ...propsReady,\n    ...scrollSeek,\n    ...totalListHeight,\n    ...initialScrollTopSystem2,\n    ...alignToBottom,\n    ...windowScroller,\n    ...scrollIntoView,\n    ...logger\n  };\n}, tup(sizeRangeSystem, initialItemCountSystem, propsReadySystem, scrollSeekSystem, totalListHeightSystem, initialScrollTopSystem, alignToBottomSystem, windowScrollerSystem, scrollIntoViewSystem, loggerSystem));\nconst listSystem = system(([{\n  totalCount,\n  sizeRanges,\n  fixedItemSize,\n  defaultItemSize,\n  trackItemSizes,\n  itemSize,\n  data,\n  firstItemIndex,\n  groupIndices,\n  statefulTotalCount,\n  gap,\n  sizes\n}, {\n  initialTopMostItemIndex,\n  scrolledToInitialItem,\n  initialItemFinalLocationReached\n}, domIO, stateLoad, followOutput, {\n  listState,\n  topItemsIndexes,\n  ...flags\n}, {\n  scrollToIndex\n}, _, {\n  topItemCount\n}, {\n  groupCounts\n}, featureGroup1]) => {\n  connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n  connect(pipe(featureGroup1.windowViewportRect, map(value => value.visibleHeight)), domIO.viewportHeight);\n  return {\n    // input\n    totalCount,\n    data,\n    firstItemIndex,\n    sizeRanges,\n    initialTopMostItemIndex,\n    scrolledToInitialItem,\n    initialItemFinalLocationReached,\n    topItemsIndexes,\n    topItemCount,\n    groupCounts,\n    fixedItemHeight: fixedItemSize,\n    defaultItemHeight: defaultItemSize,\n    gap,\n    ...followOutput,\n    // output\n    statefulTotalCount,\n    listState,\n    scrollToIndex,\n    trackItemSizes,\n    itemSize,\n    groupIndices,\n    // exported from stateFlagsSystem\n    ...flags,\n    // the bag of IO from featureGroup1System\n    ...featureGroup1,\n    ...domIO,\n    sizes,\n    ...stateLoad\n  };\n}, tup(sizeSystem, initialTopMostItemIndexSystem, domIOSystem, stateLoadSystem, followOutputSystem, listStateSystem, scrollToIndexSystem, upwardScrollFixSystem, topItemCountSystem, groupedListSystem, featureGroup1System));\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent, skipAnimationFrame) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(element => {\n    if (element === null || !element.offsetParent) {\n      return;\n    }\n    const rect = element.getBoundingClientRect();\n    const visibleWidth = rect.width;\n    let visibleHeight, offsetTop;\n    if (customScrollParent) {\n      const customScrollParentRect = customScrollParent.getBoundingClientRect();\n      const deltaTop = rect.top - customScrollParentRect.top;\n      visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n      offsetTop = deltaTop + customScrollParent.scrollTop;\n    } else {\n      visibleHeight = window.innerHeight - Math.max(0, rect.top);\n      offsetTop = rect.top + window.pageYOffset;\n    }\n    viewportInfo.current = {\n      offsetTop,\n      visibleHeight,\n      visibleWidth\n    };\n    callback(viewportInfo.current);\n  }, [callback, customScrollParent]);\n  const {\n    callbackRef,\n    ref\n  } = useSizeWithElRef(calculateInfo, true, skipAnimationFrame);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(() => {\n        requestAnimationFrame(scrollAndResizeEventHandler);\n      });\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream(index => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const HeaderFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    HeaderFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */system(([listSystem2, propsSystem]) => {\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({\n  height\n}) => /* @__PURE__ */jsx(\"div\", {\n  style: {\n    height\n  }\n});\nconst GROUP_STYLE = {\n  position: positionStickyCssValue(),\n  zIndex: 1,\n  overflowAnchor: \"none\"\n};\nconst ITEM_STYLE$1 = {\n  overflowAnchor: \"none\"\n};\nconst HORIZONTAL_ITEM_STYLE = {\n  ...ITEM_STYLE$1,\n  display: \"inline-block\",\n  height: \"100%\"\n};\nconst Items$1 = /* @__PURE__ */React.memo(function VirtuosoItems({\n  showTopList = false\n}) {\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const horizontalDirection = useEmitterValue$2(\"horizontalDirection\");\n  const {\n    callbackRef\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, showTopList ? noop : scrollContainerStateCallback, log, listGap, customScrollParent, horizontalDirection, useEmitterValue$2(\"skipAnimationFrameInResizeObserver\"));\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", value => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  const initialItemFinalLocationReached = useEmitterValue$2(\"initialItemFinalLocationReached\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    ...(horizontalDirection ? {\n      whiteSpace: \"nowrap\",\n      display: \"inline-block\",\n      height: \"100%\",\n      paddingLeft: listState.offsetTop,\n      paddingRight: listState.offsetBottom,\n      marginLeft: deviation !== 0 ? deviation : alignToBottom ? \"auto\" : 0\n    } : {\n      marginTop: deviation !== 0 ? deviation : alignToBottom ? \"auto\" : 0,\n      paddingTop: listState.offsetTop,\n      paddingBottom: listState.offsetBottom\n    }),\n    ...(initialItemFinalLocationReached ? {} : {\n      visibility: \"hidden\"\n    })\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return /* @__PURE__ */jsx(EmptyPlaceholder, {\n      ...contextPropIfNotDomElement(EmptyPlaceholder, context)\n    });\n  }\n  return /* @__PURE__ */jsx(ListComponent, {\n    ...contextPropIfNotDomElement(ListComponent, context),\n    ref: callbackRef,\n    style: containerStyle,\n    \"data-testid\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\",\n    children: (showTopList ? listState.topItems : listState.items).map(item => {\n      const index = item.originalIndex;\n      const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n      if (isSeeking) {\n        return /* @__PURE__ */createElement(ScrollSeekPlaceholder, {\n          ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n          key,\n          index: item.index,\n          height: item.size,\n          type: item.type || \"item\",\n          ...(item.type === \"group\" ? {} : {\n            groupIndex: item.groupIndex\n          })\n        });\n      }\n      if (item.type === \"group\") {\n        return /* @__PURE__ */createElement(GroupComponent, {\n          ...contextPropIfNotDomElement(GroupComponent, context),\n          key,\n          \"data-index\": index,\n          \"data-known-size\": item.size,\n          \"data-item-index\": item.index,\n          style: GROUP_STYLE\n        }, groupContent(item.index, context));\n      } else {\n        return /* @__PURE__ */createElement(ItemComponent, {\n          ...contextPropIfNotDomElement(ItemComponent, context),\n          ...itemPropIfNotDomElement(ItemComponent, item.data),\n          key,\n          \"data-index\": index,\n          \"data-known-size\": item.size,\n          \"data-item-index\": item.index,\n          \"data-item-group-index\": item.groupIndex,\n          style: horizontalDirection ? HORIZONTAL_ITEM_STYLE : ITEM_STYLE$1\n        }, hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context));\n      }\n    })\n  });\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst horizontalScrollerStyle = {\n  outline: \"none\",\n  overflowX: \"auto\",\n  position: \"relative\"\n};\nconst viewportStyle = alignToBottom => ({\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0,\n  ...(alignToBottom ? {\n    display: \"flex\",\n    flexDirection: \"column\"\n  } : {})\n});\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return {\n    context\n  };\n}\nfunction itemPropIfNotDomElement(element, item) {\n  return {\n    item: typeof element === \"string\" ? void 0 : item\n  };\n}\nconst Header$1 = /* @__PURE__ */React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const HeaderFooterTag = useEmitterValue$2(\"HeaderFooterTag\");\n  const ref = useSize(React.useMemo(() => el => headerHeight(correctItemSize(el, \"height\")), [headerHeight]), true, useEmitterValue$2(\"skipAnimationFrameInResizeObserver\"));\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? /* @__PURE__ */jsx(HeaderFooterTag, {\n    ref,\n    children: /* @__PURE__ */jsx(Header2, {\n      ...contextPropIfNotDomElement(Header2, context)\n    })\n  }) : null;\n});\nconst Footer$1 = /* @__PURE__ */React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const HeaderFooterTag = useEmitterValue$2(\"HeaderFooterTag\");\n  const ref = useSize(React.useMemo(() => el => footerHeight(correctItemSize(el, \"height\")), [footerHeight]), true, useEmitterValue$2(\"skipAnimationFrameInResizeObserver\"));\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? /* @__PURE__ */jsx(HeaderFooterTag, {\n    ref,\n    children: /* @__PURE__ */jsx(Footer2, {\n      ...contextPropIfNotDomElement(Footer2, context)\n    })\n  }) : null;\n});\nfunction buildScroller({\n  usePublisher: usePublisher2,\n  useEmitter: useEmitter2,\n  useEmitterValue: useEmitterValue2\n}) {\n  const Scroller2 = React.memo(function VirtuosoScroller({\n    style,\n    children,\n    ...props\n  }) {\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const horizontalDirection = useEmitterValue2(\"horizontalDirection\") || false;\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, scrollerRefCallback, void 0, horizontalDirection);\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    const defaultStyle = horizontalDirection ? horizontalScrollerStyle : scrollerStyle;\n    return /* @__PURE__ */jsx(ScrollerComponent, {\n      ref: scrollerRef,\n      style: {\n        ...defaultStyle,\n        ...style\n      },\n      \"data-testid\": \"virtuoso-scroller\",\n      \"data-virtuoso-scroller\": true,\n      tabIndex: 0,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context),\n      children\n    });\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller({\n  usePublisher: usePublisher2,\n  useEmitter: useEmitter2,\n  useEmitterValue: useEmitterValue2\n}) {\n  const Scroller2 = React.memo(function VirtuosoWindowScroller({\n    style,\n    children,\n    ...props\n  }) {\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, noop, customScrollParent);\n    useIsomorphicLayoutEffect(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return /* @__PURE__ */jsx(ScrollerComponent, {\n      style: {\n        position: \"relative\",\n        ...style,\n        ...(totalListHeight !== 0 ? {\n          height: totalListHeight + deviation\n        } : {})\n      },\n      \"data-virtuoso-scroller\": true,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context),\n      children\n    });\n  });\n  return Scroller2;\n}\nconst Viewport$2 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  const horizontalDirection = useEmitterValue$2(\"horizontalDirection\");\n  const viewportSizeCallbackMemo = React.useMemo(() => compose(viewportHeight, el => correctItemSize(el, horizontalDirection ? \"width\" : \"height\")), [viewportHeight, horizontalDirection]);\n  const viewportRef = useSize(viewportSizeCallbackMemo, true, useEmitterValue$2(\"skipAnimationFrameInResizeObserver\"));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */jsx(\"div\", {\n    style: viewportStyle(alignToBottom),\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\",\n    children\n  });\n};\nconst WindowViewport$2 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, useEmitterValue$2(\"skipAnimationFrameInResizeObserver\"));\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle(alignToBottom),\n    \"data-viewport-type\": \"window\",\n    children\n  });\n};\nconst TopItemListContainer = ({\n  children\n}) => {\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\") || \"div\";\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = {\n    ...topItemListStyle,\n    marginTop: `${headerHeight}px`\n  };\n  const context = useEmitterValue$2(\"context\");\n  return /* @__PURE__ */jsx(TopItemList, {\n    style,\n    ...contextPropIfNotDomElement(TopItemList, context),\n    children\n  });\n};\nconst ListRoot = /* @__PURE__ */React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */jsxs(TheScroller, {\n    ...props,\n    children: [showTopList && /* @__PURE__ */jsx(TopItemListContainer, {\n      children: /* @__PURE__ */jsx(Items$1, {\n        showTopList: true\n      })\n    }), /* @__PURE__ */jsxs(TheViewport, {\n      children: [/* @__PURE__ */jsx(Header$1, {}), /* @__PURE__ */jsx(Items$1, {}), /* @__PURE__ */jsx(Footer$1, {})]\n    })]\n  });\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */systemToComponent(combinedSystem$2, {\n  required: {},\n  optional: {\n    restoreStateFrom: \"restoreStateFrom\",\n    context: \"context\",\n    followOutput: \"followOutput\",\n    itemContent: \"itemContent\",\n    groupContent: \"groupContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    groupCounts: \"groupCounts\",\n    topItemCount: \"topItemCount\",\n    firstItemIndex: \"firstItemIndex\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"HeaderFooterTag\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\",\n    horizontalDirection: \"horizontalDirection\",\n    skipAnimationFrameInResizeObserver: \"skipAnimationFrameInResizeObserver\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    autoscrollToBottom: \"autoscrollToBottom\",\n    getState: \"getState\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, ListRoot);\nconst Scroller$2 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst WindowScroller$2 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{\n    index: 0\n  }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst {\n  round,\n  ceil,\n  floor,\n  min,\n  max\n} = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({\n    length: endIndex - startIndex + 1\n  }).map((_, i) => {\n    const dataItem = data === null ? null : data[i + startIndex];\n    return {\n      index: i + startIndex,\n      data: dataItem\n    };\n  });\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */system(([{\n  overscan,\n  visibleRange,\n  listBoundary,\n  increaseViewportBy\n}, {\n  scrollTop,\n  viewportHeight,\n  scrollBy,\n  scrollTo,\n  smoothScrollTargetReached,\n  scrollContainerState,\n  footerHeight,\n  headerHeight\n}, stateFlags, scrollSeek, {\n  propsReady,\n  didMount\n}, {\n  windowViewportRect,\n  useWindowScroll,\n  customScrollParent,\n  windowScrollContainerState,\n  windowScrollTo\n}, log]) => {\n  const totalCount = statefulStream(0);\n  const initialItemCount = statefulStream(0);\n  const gridState = statefulStream(INITIAL_GRID_STATE);\n  const viewportDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const itemDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const scrollToIndex = stream();\n  const scrollHeight = stream();\n  const deviation = statefulStream(0);\n  const data = statefulStream(null);\n  const gap = statefulStream({\n    row: 0,\n    column: 0\n  });\n  const stateChanged = stream();\n  const restoreStateFrom = stream();\n  const stateRestoreInProgress = statefulStream(false);\n  const initialTopMostItemIndex = statefulStream(0);\n  const scrolledToInitialItem = statefulStream(true);\n  const scrollScheduled = statefulStream(false);\n  const horizontalDirection = statefulStream(false);\n  subscribe(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location)), () => {\n    publish(scrolledToInitialItem, false);\n  });\n  subscribe(pipe(combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled), filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2,, scrollScheduled2]) => {\n    return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;\n  })), ([,,,, initialTopMostItemIndex2]) => {\n    publish(scrollScheduled, true);\n    skipFrames(1, () => {\n      publish(scrollToIndex, initialTopMostItemIndex2);\n    });\n    handleNext(pipe(scrollTop), () => {\n      publish(listBoundary, [0, 0]);\n      publish(scrolledToInitialItem, true);\n    });\n  });\n  connect(pipe(restoreStateFrom, filter(value => value !== void 0 && value !== null && value.scrollTop > 0), mapTo(0)), initialItemCount);\n  subscribe(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)), ([, snapshot]) => {\n    if (!snapshot) {\n      return;\n    }\n    publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);\n    publish(gap, snapshot.gap);\n    if (snapshot.scrollTop > 0) {\n      publish(stateRestoreInProgress, true);\n      handleNext(pipe(scrollTop, skip(1)), _value => {\n        publish(stateRestoreInProgress, false);\n      });\n      publish(scrollTo, {\n        top: snapshot.scrollTop\n      });\n    }\n  });\n  connect(pipe(viewportDimensions, map(({\n    height\n  }) => height)), viewportHeight);\n  connect(pipe(combineLatest(duc(viewportDimensions, dimensionComparator), duc(itemDimensions, dimensionComparator), duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row), duc(scrollTop)), map(([viewport, item, gap2, scrollTop2]) => ({\n    viewport,\n    item,\n    gap: gap2,\n    scrollTop: scrollTop2\n  }))), stateChanged);\n  connect(pipe(combineLatest(duc(totalCount), visibleRange, duc(gap, gapComparator), duc(itemDimensions, dimensionComparator), duc(viewportDimensions, dimensionComparator), duc(data), duc(initialItemCount), duc(stateRestoreInProgress), duc(scrolledToInitialItem), duc(initialTopMostItemIndex)), filter(([,,,,,,, stateRestoreInProgress2]) => {\n    return !stateRestoreInProgress2;\n  }), map(([totalCount2, [startOffset, endOffset], gap2, item, viewport, data2, initialItemCount2,, scrolledToInitialItem2, initialTopMostItemIndex2]) => {\n    const {\n      row: rowGap,\n      column: columnGap\n    } = gap2;\n    const {\n      height: itemHeight,\n      width: itemWidth\n    } = item;\n    const {\n      width: viewportWidth\n    } = viewport;\n    if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {\n      return INITIAL_GRID_STATE;\n    }\n    if (itemWidth === 0) {\n      const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);\n      const endIndex2 = startIndex2 + Math.max(initialItemCount2 - 1, 0);\n      return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));\n    }\n    const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n    let startIndex;\n    let endIndex;\n    if (!scrolledToInitialItem2) {\n      startIndex = 0;\n      endIndex = -1;\n    } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {\n      startIndex = 0;\n      endIndex = initialItemCount2 - 1;\n    } else {\n      startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n      endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n      endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n      startIndex = min(endIndex, max(0, startIndex));\n    }\n    const items = buildItems(startIndex, endIndex, data2);\n    const {\n      top,\n      bottom\n    } = gridLayout(viewport, gap2, item, items);\n    const rowCount = ceil(totalCount2 / perRow);\n    const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n    const offsetBottom = totalHeight - bottom;\n    return {\n      items,\n      offsetTop: top,\n      offsetBottom,\n      top,\n      bottom,\n      itemHeight,\n      itemWidth\n    };\n  })), gridState);\n  connect(pipe(data, filter(data2 => data2 !== null), map(data2 => data2.length)), totalCount);\n  connect(pipe(combineLatest(viewportDimensions, itemDimensions, gridState, gap), filter(([viewportDimensions2, itemDimensions2, {\n    items\n  }]) => {\n    return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;\n  }), map(([viewportDimensions2, itemDimensions2, {\n    items\n  }, gap2]) => {\n    const {\n      top,\n      bottom\n    } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);\n    return [top, bottom];\n  }), distinctUntilChanged(tupleComparator)), listBoundary);\n  const hasScrolled = statefulStream(false);\n  connect(pipe(scrollTop, withLatestFrom(hasScrolled), map(([scrollTop2, hasScrolled2]) => {\n    return hasScrolled2 || scrollTop2 !== 0;\n  })), hasScrolled);\n  const endReached = streamFromEmitter(pipe(combineLatest(gridState, totalCount), filter(([{\n    items\n  }]) => items.length > 0), withLatestFrom(hasScrolled), filter(([[gridState2, totalCount2], hasScrolled2]) => {\n    const lastIndex = gridState2.items[gridState2.items.length - 1].index;\n    const isLastItemRendered = lastIndex === totalCount2 - 1;\n    if (hasScrolled2) return isLastItemRendered;\n    const isFullyRendered = gridState2.bottom > 0 && gridState2.itemHeight > 0 && gridState2.offsetBottom === 0 && gridState2.items.length === totalCount2;\n    return isFullyRendered && isLastItemRendered;\n  }), map(([[, totalCount2]]) => {\n    return totalCount2 - 1;\n  }), distinctUntilChanged()));\n  const startReached = streamFromEmitter(pipe(duc(gridState), filter(({\n    items\n  }) => {\n    return items.length > 0 && items[0].index === 0;\n  }),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  mapTo(0), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(duc(gridState), withLatestFrom(stateRestoreInProgress), filter(([{\n    items\n  }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2), map(([{\n    items\n  }]) => {\n    return {\n      startIndex: items[0].index,\n      endIndex: items[items.length - 1].index\n    };\n  }), distinctUntilChanged(rangeComparator), throttleTime(0)));\n  connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n  connect(pipe(scrollToIndex, withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap), map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    let index = normalLocation.index;\n    if (index === \"LAST\") {\n      index = totalCount2 - 1;\n    }\n    index = max(0, index, min(totalCount2 - 1, index));\n    let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);\n    if (align === \"end\") {\n      top = round(top - viewportDimensions2.height + itemDimensions2.height);\n    } else if (align === \"center\") {\n      top = round(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);\n    }\n    if (offset) {\n      top += offset;\n    }\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  const totalListHeight = statefulStreamFromEmitter(pipe(gridState, map(gridState2 => {\n    return gridState2.offsetBottom + gridState2.bottom;\n  })), 0);\n  connect(pipe(windowViewportRect, map(viewportInfo => ({\n    width: viewportInfo.visibleWidth,\n    height: viewportInfo.visibleHeight\n  }))), viewportDimensions);\n  return {\n    // input\n    data,\n    totalCount,\n    viewportDimensions,\n    itemDimensions,\n    scrollTop,\n    scrollHeight,\n    overscan,\n    increaseViewportBy,\n    scrollBy,\n    scrollTo,\n    scrollToIndex,\n    smoothScrollTargetReached,\n    windowViewportRect,\n    windowScrollTo,\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState,\n    deviation,\n    scrollContainerState,\n    footerHeight,\n    headerHeight,\n    initialItemCount,\n    gap,\n    restoreStateFrom,\n    ...scrollSeek,\n    initialTopMostItemIndex,\n    horizontalDirection,\n    // output\n    gridState,\n    totalListHeight,\n    ...stateFlags,\n    startReached,\n    endReached,\n    rangeChanged,\n    stateChanged,\n    propsReady,\n    stateRestoreInProgress,\n    ...log\n  };\n}, tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem));\nfunction gridLayout(viewport, gap, item, items) {\n  const {\n    height: itemHeight\n  } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return {\n    top,\n    bottom\n  };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  const readyStateChanged = statefulStream(false);\n  const reportReadyState = statefulStream(false);\n  connect(duc(reportReadyState), readyStateChanged);\n  return {\n    readyStateChanged,\n    reportReadyState,\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */system(([gridSystem2, gridComponentPropsSystem2]) => {\n  return {\n    ...gridSystem2,\n    ...gridComponentPropsSystem2\n  };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const stateRestoreInProgress = useEmitterValue$1(\"stateRestoreInProgress\");\n  const reportReadyState = usePublisher$1(\"reportReadyState\");\n  const listRef = useSize(React.useMemo(() => el => {\n    const scrollHeight = el.parentElement.parentElement.scrollHeight;\n    scrollHeightCallback(scrollHeight);\n    const firstItem = el.firstChild;\n    if (firstItem) {\n      const {\n        width,\n        height\n      } = firstItem.getBoundingClientRect();\n      itemDimensions({\n        width,\n        height\n      });\n    }\n    gridGap({\n      row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n      column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n    });\n  }, [scrollHeightCallback, itemDimensions, gridGap, log]), true, false);\n  useIsomorphicLayoutEffect(() => {\n    if (gridState.itemHeight > 0 && gridState.itemWidth > 0) {\n      reportReadyState(true);\n    }\n  }, [gridState]);\n  if (stateRestoreInProgress) {\n    return null;\n  }\n  return /* @__PURE__ */jsx(ListComponent, {\n    ref: listRef,\n    className: listClassName,\n    ...contextPropIfNotDomElement(ListComponent, context),\n    style: {\n      paddingTop: gridState.offsetTop,\n      paddingBottom: gridState.offsetBottom\n    },\n    \"data-testid\": \"virtuoso-item-list\",\n    children: gridState.items.map(item => {\n      const key = computeItemKey(item.index, item.data, context);\n      return isSeeking ? /* @__PURE__ */jsx(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        index: item.index,\n        height: gridState.itemHeight,\n        width: gridState.itemWidth\n      }, key) : /* @__PURE__ */createElement(ItemComponent, {\n        ...contextPropIfNotDomElement(ItemComponent, context),\n        className: itemClassName,\n        \"data-index\": item.index,\n        key\n      }, itemContent(item.index, item.data, context));\n    })\n  });\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const HeaderFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(React.useMemo(() => el => headerHeight(correctItemSize(el, \"height\")), [headerHeight]), true, false);\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? /* @__PURE__ */jsx(HeaderFooterTag, {\n    ref,\n    children: /* @__PURE__ */jsx(Header2, {\n      ...contextPropIfNotDomElement(Header2, context)\n    })\n  }) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const HeaderFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(React.useMemo(() => el => footerHeight(correctItemSize(el, \"height\")), [footerHeight]), true, false);\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? /* @__PURE__ */jsx(HeaderFooterTag, {\n    ref,\n    children: /* @__PURE__ */jsx(Footer2, {\n      ...contextPropIfNotDomElement(Footer2, context)\n    })\n  }) : null;\n});\nconst Viewport$1 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize(React.useMemo(() => el => {\n    viewportDimensions(el.getBoundingClientRect());\n  }, [viewportDimensions]), true, false);\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({\n        height: ctx.viewportHeight,\n        width: ctx.viewportWidth\n      });\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */jsx(\"div\", {\n    style: viewportStyle(false),\n    ref: viewportRef,\n    children\n  });\n};\nconst WindowViewport$1 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, false);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: ctx.viewportWidth\n      });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle(false),\n    children\n  });\n};\nconst GridRoot = /* @__PURE__ */React.memo(function GridRoot2({\n  ...props\n}) {\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */jsx(TheScroller, {\n    ...props,\n    children: /* @__PURE__ */jsxs(TheViewport, {\n      children: [/* @__PURE__ */jsx(Header, {}), /* @__PURE__ */jsx(GridItems, {}), /* @__PURE__ */jsx(Footer, {})]\n    })\n  });\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */systemToComponent(combinedSystem$1, {\n  optional: {\n    context: \"context\",\n    totalCount: \"totalCount\",\n    overscan: \"overscan\",\n    itemContent: \"itemContent\",\n    components: \"components\",\n    computeItemKey: \"computeItemKey\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    listClassName: \"listClassName\",\n    itemClassName: \"itemClassName\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\",\n    restoreStateFrom: \"restoreStateFrom\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    increaseViewportBy: \"increaseViewportBy\"\n  },\n  methods: {\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    scrollToIndex: \"scrollToIndex\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    stateChanged: \"stateChanged\",\n    readyStateChanged: \"readyStateChanged\"\n  }\n}, GridRoot);\nconst Scroller$1 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nconst WindowScroller$1 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => /* @__PURE__ */jsxs(\"td\", {\n    children: [\"Item $\", index]\n  }));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */system(([listSystem2, propsSystem]) => {\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({\n  height\n}) => /* @__PURE__ */jsx(\"tr\", {\n  children: /* @__PURE__ */jsx(\"td\", {\n    style: {\n      height\n    }\n  })\n});\nconst DefaultFillerRow = ({\n  height\n}) => /* @__PURE__ */jsx(\"tr\", {\n  children: /* @__PURE__ */jsx(\"td\", {\n    style: {\n      height,\n      padding: 0,\n      border: 0\n    }\n  })\n});\nconst ITEM_STYLE = {\n  overflowAnchor: \"none\"\n};\nconst Items = /* @__PURE__ */React.memo(function VirtuosoItems2({\n  showTopList = false\n}) {\n  const listState = useEmitterValue(\"listState\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const context = useEmitterValue(\"context\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const fixedHeaderHeight = useEmitterValue(\"fixedHeaderHeight\");\n  const itemContent = useEmitterValue(\"itemContent\");\n  const topItemOffsets = (showTopList ? listState.topItems : []).reduce((acc, item, index) => {\n    if (index === 0) {\n      acc.push(item.size);\n    } else {\n      acc.push(acc[index - 1] + item.size);\n    }\n    return acc;\n  }, []);\n  const items = (showTopList ? listState.topItems : listState.items).map(item => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    const offsetTop = showTopList ? index === 0 ? 0 : topItemOffsets[index - 1] : 0;\n    if (isSeeking) {\n      return /* @__PURE__ */createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\"\n      });\n    }\n    return /* @__PURE__ */createElement(TableRowComponent, {\n      ...contextPropIfNotDomElement(TableRowComponent, context),\n      ...itemPropIfNotDomElement(TableRowComponent, item.data),\n      key,\n      \"data-index\": index,\n      \"data-known-size\": item.size,\n      \"data-item-index\": item.index,\n      style: showTopList ? {\n        overflowAnchor: \"none\",\n        position: \"sticky\",\n        zIndex: 2,\n        top: fixedHeaderHeight + offsetTop\n      } : ITEM_STYLE\n    }, itemContent(item.index, item.data, context));\n  });\n  return /* @__PURE__ */jsx(Fragment, {\n    children: items\n  });\n});\nconst TableBody = /* @__PURE__ */React.memo(function TableVirtuosoBody() {\n  const listState = useEmitterValue(\"listState\");\n  const showTopList = useEmitterValue(\"topItemsIndexes\").length > 0;\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const {\n    callbackRef,\n    ref\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, scrollContainerStateCallback, log, void 0, customScrollParent, false, useEmitterValue(\"skipAnimationFrameInResizeObserver\"));\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", value => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return /* @__PURE__ */jsx(EmptyPlaceholder, {\n      ...contextPropIfNotDomElement(EmptyPlaceholder, context)\n    });\n  }\n  const topItemsSize = (showTopList ? listState.topItems : []).reduce((acc, item) => acc + item.size, 0);\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation - topItemsSize;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */jsx(FillerRow, {\n    height: paddingTop,\n    context\n  }, \"padding-top\") : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */jsx(FillerRow, {\n    height: paddingBottom,\n    context\n  }, \"padding-bottom\") : null;\n  return /* @__PURE__ */jsxs(TableBodyComponent, {\n    ref: callbackRef,\n    \"data-testid\": \"virtuoso-item-list\",\n    ...contextPropIfNotDomElement(TableBodyComponent, context),\n    children: [paddingTopEl, showTopList && /* @__PURE__ */jsx(Items, {\n      showTopList: true\n    }), /* @__PURE__ */jsx(Items, {}), paddingBottomEl]\n  });\n});\nconst Viewport = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(React.useMemo(() => compose(viewportHeight, el => correctItemSize(el, \"height\")), [viewportHeight]), true, useEmitterValue(\"skipAnimationFrameInResizeObserver\"));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */jsx(\"div\", {\n    style: viewportStyle(false),\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\",\n    children\n  });\n};\nconst WindowViewport = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, useEmitterValue(\"skipAnimationFrameInResizeObserver\"));\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle(false),\n    \"data-viewport-type\": \"window\",\n    children\n  });\n};\nconst TableRoot = /* @__PURE__ */React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(React.useMemo(() => compose(fixedHeaderHeight, el => correctItemSize(el, \"height\")), [fixedHeaderHeight]), true, useEmitterValue(\"skipAnimationFrameInResizeObserver\"));\n  const tfootRef = useSize(React.useMemo(() => compose(fixedFooterHeight, el => correctItemSize(el, \"height\")), [fixedFooterHeight]), true, useEmitterValue(\"skipAnimationFrameInResizeObserver\"));\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? /* @__PURE__ */jsx(TheTHead, {\n    style: {\n      zIndex: 2,\n      position: \"sticky\",\n      top: 0\n    },\n    ref: theadRef,\n    ...contextPropIfNotDomElement(TheTHead, context),\n    children: fixedHeaderContent()\n  }, \"TableHead\") : null;\n  const theFoot = fixedFooterContent ? /* @__PURE__ */jsx(TheTFoot, {\n    style: {\n      zIndex: 1,\n      position: \"sticky\",\n      bottom: 0\n    },\n    ref: tfootRef,\n    ...contextPropIfNotDomElement(TheTFoot, context),\n    children: fixedFooterContent()\n  }, \"TableFoot\") : null;\n  return /* @__PURE__ */jsx(TheScroller, {\n    ...props,\n    children: /* @__PURE__ */jsx(TheViewport, {\n      children: /* @__PURE__ */jsxs(TheTable, {\n        style: {\n          borderSpacing: 0,\n          overflowAnchor: \"none\"\n        },\n        ...contextPropIfNotDomElement(TheTable, context),\n        children: [theHead, /* @__PURE__ */jsx(TableBody, {}, \"TableBody\"), theFoot]\n      })\n    })\n  });\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */systemToComponent(combinedSystem, {\n  required: {},\n  optional: {\n    restoreStateFrom: \"restoreStateFrom\",\n    context: \"context\",\n    followOutput: \"followOutput\",\n    firstItemIndex: \"firstItemIndex\",\n    itemContent: \"itemContent\",\n    fixedHeaderContent: \"fixedHeaderContent\",\n    fixedFooterContent: \"fixedFooterContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    topItemCount: \"topItemCount\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    groupCounts: \"groupCounts\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    getState: \"getState\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, TableRoot);\nconst Scroller = /* @__PURE__ */buildScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst WindowScroller = /* @__PURE__ */buildWindowScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst TableVirtuoso = Table;\nexport { GroupedVirtuoso, LogLevel, TableVirtuoso, Virtuoso, VirtuosoGrid, VirtuosoGridMockContext, VirtuosoMockContext };","map":{"version":3,"names":["jsx","jsxs","Fragment","React","createElement","ReactDOM","PUBLISH","SUBSCRIBE","RESET","VALUE","compose","a","b","arg","thrush","proc","curry2to1","arg1","arg2","curry1to0","tap","tup","args","call","always","value","joinProc","procs","map","isDefined","noop","subscribe","emitter","subscription","publish","publisher","reset","getValue","depot","connect","handleNext","unsub","stream","subscriptions","action","splice","length","push","indexOf","slice","forEach","Error","statefulStream","initial","innerSubject","eventHandler","currentSubscription","cleanup","streamFromEmitter","stream2","statefulStreamFromEmitter","combineOperators","operators","subscriber","reduceRight","pipe","source","project","defaultComparator","previous","next","distinctUntilChanged","comparator","current","done","filter","predicate","mapTo","scan","scanner","skip","times","throttleTime","interval","currentValue","timeout","setTimeout","debounceTime","clearTimeout","withLatestFrom","sources","values","Array","called","pendingCall","allCalled","Math","pow","index","bit","prevCalled","call2","concat","merge","duc","combineLatest","emitters","system","constructor","dependencies","singleton","id","Symbol","init","systemSpec","singletons","Map","_init","id2","has","get","system2","e","set","omit","keys","obj","result","idx","len","prop","hasOwnProperty","useIsomorphicLayoutEffect$1","document","useLayoutEffect","useEffect","systemToComponent","map2","Root","requiredPropNames","Object","required","optionalPropNames","optional","methodNames","methods","eventNames","events","Context","createContext","applyPropsToSystem","props","requiredPropName","optionalPropName","buildMethods","reduce","acc","methodName","buildEventHandlers","handlers","eventName","Component","forwardRef","propsWithChildren","ref","children","useState","system22","useImperativeHandle","RootComponent","Provider","usePublisher2","key","useCallback","useContext","useEmitterValue18","cb","c","useSyncExternalStore","useEmitterValueLegacy","setValue","useEmitterValue2","version","startsWith","useEmitter2","callback","context","usePublisher","useEmitterValue","useEmitter","useIsomorphicLayoutEffect","LogLevel","LogLevel2","CONSOLE_METHOD_MAP","getGlobalThis","globalThis","window","loggerSystem","logLevel","log","label","message","level","_a","currentLevel","console","useSizeWithElRef","enabled","skipAnimationFrame","useRef","callbackRef","_el","ResizeObserver","observer","useMemo","entries","code","element","target","offsetParent","requestAnimationFrame","elRef","observe","unobserve","useSize","useChangedListContentsSizes","itemSize","scrollContainerStateCallback","gap","customScrollParent","horizontalDirection","memoedCallback","el","ranges","getChangedChildSizes","scrollableElement","parentElement","dataset","windowScrolling","lastElementChild","scrollTop","scrollLeft","pageXOffset","documentElement","pageYOffset","scrollHeight","scrollWidth","viewportHeight","offsetWidth","offsetHeight","innerWidth","innerHeight","max","resolveGapValue$1","getComputedStyle","columnGap","rowGap","field","results","i","child","item","parseInt","knownSize","parseFloat","size","ERROR","lastResult","endIndex","startIndex","property","endsWith","WARN","correctItemSize","dimension","round","getBoundingClientRect","approximatelyEqual","num1","num2","abs","useScrollTop","smoothScrollTargetReached","scrollerElement","scrollerRefCallback","scrollerRef","scrollTopTarget","timeoutRef","handler","ev","windowScroll","suppressFlushSync","flushSync","localRef","addEventListener","passive","removeEventListener","scrollToCallback","location","scrollerElement2","isSmooth","behavior","maxScrollTop","top","ceil","min","left","scrollTo","scrollByCallback","scrollBy","domIOSystem","scrollContainerState","deviation","statefulScrollTop","headerHeight","fixedHeaderHeight","fixedFooterHeight","footerHeight","scrollingInProgress","skipAnimationFrameInResizeObserver","scrollTop2","scrollHeight2","NIL_NODE","lvl","newAANode","k","v","l","r","empty","node","newTree","remove","lastKey","lastValue","last","adjust","clone","deleteLast","find","findMaxKeyValue","Infinity","Number","insert","rebalance","walkWithin","start","end","walk","isSingle","split","skew","rl","rlvl","rangesWithin","adjustedStart","toRanges","arrayToRanges","items","parser","nextIndex","nextValue","nodes","findIndexOfClosestSmallerOrEqual","floor","match","join","findClosestSmallerOrEqual","findRange","startValue","endValue","recalcSystem","recalcInProgress","rangeIncludes","refRange","range","affectedGroupCount","offset","groupIndices","recognizedOffsetItems","groupIndex","offsetIsExact","insertRanges","sizeTree","syncStart","overlappingRanges","some","firstPassDone","shouldInsert","rangeStart","rangeEnd","rangeValue","initialSizeState","offsetTree","groupOffsetTree","lastIndex","lastOffset","lastSize","indexComparator","itemIndex","offsetComparator","itemOffset","offsetPointParser","point","rangesWithinOffsets","tree","startOffset","endOffset","minStartIndex","createOffsetTree","prevOffsetTree","prevIndex","prevSize","prevOffset","offsetInfo","kv","startIndex2","indexOffset","aOffset","sizeStateReducer","state","DEBUG","newSizeTree","groupSize","newOffsetTree","offsetOf","itemCount","isGroupLocation","originalIndexFromLocation","sizes","numericIndex","originalIndexFromItemIndex","hasGroups","groupOffset","sizeTreeToRanges","sizeArray","nextSize","SIZE_MAP","sizeSystem","sizeRanges","totalCount","statefulTotalCount","unshiftWith","shiftWith","firstItemIndex","fixedItemSize","defaultItemSize","data","prevGroupIndices","prev","curr","indexes","groupIndices2","sizes2","gap2","totalCount2","trackItemSizes","listRefresh","oldSizes","_","newSizes","changed","diff","val","prevGroupIndicesValue","log2","beforeUnshiftWith","unshiftWith2","groupedMode","initialRanges","defaultSize","firstGroupSize","prependedGroupItemsCount","theGroupIndex","groupItemCount","sizeTreeKV","firstGroupIsExpanded","shift","shiftWithOffset","shiftWith2","newFirstItemIndex","removedItemsCount","aGroupIsShrunk","nextItemSize","SUPPORTS_SCROLL_TO_OPTIONS","style","normalizeIndexLocation","align","scrollToIndexSystem","scrollToIndex","scrollTargetReached","topListHeight","unsubscribeNextListRefresh","cleartTimeoutRef","unsubscribeListRefresh","viewportHeight2","topListHeight2","headerHeight2","footerHeight2","fixedHeaderHeight2","fixedFooterHeight2","normalLocation","retry","listChanged","watchChangesFor","limit","UP","DOWN","NONE$1","INITIAL_BOTTOM_STATE","atBottom","notAtBottomBecause","offsetBottom","DEFAULT_AT_TOP_THRESHOLD","stateFlagsSystem","isAtBottom","isAtTop","atBottomStateChange","atTopStateChange","atBottomThreshold","atTopThreshold","isScrolling","isScrollingBy","atTopThreshold2","atBottomState","_headerHeight","_footerHeight","atBottomThreshold2","isAtBottom2","atBottomBecause","scrollTopDelta","lastJumpDueToItemResize","jump","scrollDirection","direction","prevScrollTop","scrollVelocity","isScrolling2","propsReadySystem","propsReady","didMount","ready","skipFrames","frameCount","getInitialTopMostItemIndexNumber","initialTopMostItemIndexSystem","scrolledToInitialItem","initialTopMostItemIndex","initialItemFinalLocationReached","didMount2","scrolledToInitialItem2","defaultItemSize2","scrollScheduled","initialTopMostItemIndex2","normalizeFollowOutput","follow","behaviorFromFollowOutput","followOutputSystem","followOutput","autoscrollToBottom","pendingScrollHandle","scrollToBottom","followOutputBehavior","followOutput2","scrollingInProgress2","shouldFollow","trapNextSizeIncrease","cancel","refreshed","groupCountsToIndicesAndCount","counts","groupCount","groupedListSystem","groupCounts","topItemsIndexes","groupIndicesAndCount","tupleComparator","rangeComparator","TOP","BOTTOM","NONE","getOverscan","overscan","main","reverse","getViewportIncrease","sizeRangeSystem","listBoundary","increaseViewportBy","visibleRange","listTop","listBottom","overscan2","deviation2","increaseViewportBy2","stickyHeaderHeight","headerVisible","topViewportAddition","bottomViewportAddition","probeItemSet","EMPTY_LIST_STATE","topItems","offsetTop","bottom","transposeItems","originalIndex","transposedItems","groupRanges","currentRange","currentGroupIndex","transposedItem","type","buildListState","lastItem","total","height","buildListStateFromItemCount","includedGroupsCount","adjustedCount","initialTopMostItemIndexNumber","from","listStateSystem","groupedListSystem2","rangeTopListHeight","stateFlags","initialItemCount","itemsRendered","listState","mount","recalcInProgress2","data2","dataChangeInProgress","topItemsIndexes2","firstItemIndex2","sizesValue","initialItemCountValue","rangeStartIndex","rangeEndIndex","offsetPointRanges","maxIndex","endReached","count","startReached","rangeChanged","initialItemCountSystem","initialTopMostItemIndexValue","scrollSeekSystem","isSeeking","scrollSeekConfiguration","config","speed","isSeeking2","exit","enter","velocity","change","scrollSeekRangeChanged","topItemCountSystem","topItemCount","totalListHeightSystem","totalListHeightChanged","totalListHeight","listState2","simpleMemoize","func","isMobileSafari","test","navigator","userAgent","upwardScrollFixSystem","deviationOffset","prevItems","prevTotalCount","prevTotalHeight","lastJumpDueToItemResize2","totalHeight","newDev","atStart","amount","scrollDirection2","scrollByWith","deviationAmount","is","recalc","getItemOffset","defaultGroupSize","initialScrollTopSystem","initialScrollTop","alignToBottomSystem","alignToBottom","paddingTopAddition","totalListHeight2","windowScrollerSystem","windowScrollContainerState","windowViewportRect","windowScrollTo","useWindowScroll","windowScrollTop","scrollTo2","defaultCalculateViewLocation","itemTop","itemTop2","itemBottom","viewportTop","viewportBottom","locationParams","rest","scrollIntoViewSystem","scrollIntoView","viewLocation","calculateViewLocation","actualIndex","stateLoadSystem","getState","restoreStateFrom","statefulWindowScrollContainerState","statefulWindowViewportRect","useWindowScroll2","windowScrollContainerState2","windowViewportRect2","locationFromSnapshot","snapshot","featureGroup1System","sizeRange","scrollSeek","initialScrollTopSystem2","windowScroller","logger","listSystem","domIO","stateLoad","flags","featureGroup1","visibleHeight","fixedItemHeight","defaultItemHeight","WEBKIT_STICKY","STICKY","positionStickyCssValue","position","useWindowViewportRectRef","viewportInfo","calculateInfo","rect","visibleWidth","width","customScrollParentRect","deltaTop","scrollAndResizeEventHandler","VirtuosoMockContext","VirtuosoGridMockContext","identity","listComponentPropsSystem","itemContent","groupContent","components","computeItemKey","HeaderFooterTag","distinctProp","propName","defaultValue","components2","FooterComponent","HeaderComponent","TopItemListComponent","ListComponent","ItemComponent","GroupComponent","ScrollerComponent","EmptyPlaceholder","ScrollSeekPlaceholder","combinedSystem$2","listSystem2","propsSystem","DefaultScrollSeekPlaceholder$1","GROUP_STYLE","zIndex","overflowAnchor","ITEM_STYLE$1","HORIZONTAL_ITEM_STYLE","display","Items$1","memo","VirtuosoItems","showTopList","useEmitterValue$2","usePublisher$2","windowScrollContainerStateCallback","_scrollContainerStateCallback","listGap","setDeviation","useEmitter$2","hasGroups2","containerStyle","boxSizing","whiteSpace","paddingLeft","paddingRight","marginLeft","marginTop","paddingTop","paddingBottom","visibility","contextPropIfNotDomElement","itemPropIfNotDomElement","scrollerStyle","outline","overflowY","WebkitOverflowScrolling","horizontalScrollerStyle","overflowX","viewportStyle","flexDirection","topItemListStyle","Header$1","VirtuosoHeader","Header2","Footer$1","VirtuosoFooter","Footer2","buildScroller","Scroller2","VirtuosoScroller","defaultStyle","tabIndex","buildWindowScroller","VirtuosoWindowScroller","Viewport$2","ctx","viewportSizeCallbackMemo","viewportRef","itemHeight","WindowViewport$2","TopItemListContainer","TopItemList","ListRoot","VirtuosoRoot","TheScroller","WindowScroller$2","Scroller$2","TheViewport","List","headerFooterTag","Virtuoso","GroupedVirtuoso","INITIAL_GRID_STATE","itemWidth","PROBE_GRID_STATE","buildProbeGridState","buildItems","dataItem","gapComparator","column","row","dimensionComparator","gridSystem","gridState","viewportDimensions","itemDimensions","stateChanged","stateRestoreInProgress","itemDimensions2","viewportDimensions2","scrollScheduled2","viewport","_value","stateRestoreInProgress2","initialItemCount2","viewportWidth","endIndex2","perRow","itemsPerRow","gridLayout","rowCount","hasScrolled","hasScrolled2","gridState2","isLastItemRendered","isFullyRendered","gridComponentPropsSystem","itemClassName","listClassName","readyStateChanged","reportReadyState","combinedSystem$1","gridSystem2","gridComponentPropsSystem2","GridItems","GridItems2","useEmitterValue$1","scrollHeightCallback","usePublisher$1","gridGap","listRef","firstItem","firstChild","resolveGapValue","className","Header","VirtuosoHeader2","Footer","VirtuosoGridFooter","Viewport$1","WindowViewport$1","GridRoot","GridRoot2","WindowScroller$1","Scroller$1","Grid","useEmitter$1","VirtuosoGrid","tableComponentPropsSystem","fixedHeaderContent","fixedFooterContent","TableComponent","TableHeadComponent","TableFooterComponent","TableBodyComponent","TableRowComponent","FillerRow","combinedSystem","DefaultScrollSeekPlaceholder","DefaultFillerRow","padding","border","ITEM_STYLE","Items","VirtuosoItems2","topItemOffsets","TableBody","TableVirtuosoBody","topItemsSize","paddingTopEl","paddingBottomEl","Viewport","WindowViewport","TableRoot","TableVirtuosoRoot","theadRef","tfootRef","WindowScroller","Scroller","TheTable","TheTHead","TheTFoot","theHead","theFoot","borderSpacing","Table","TableVirtuoso"],"sources":["/Users/nancy/Documents/Front-end-test-Nancy/node_modules/react-virtuoso/dist/index.mjs"],"sourcesContent":["import { jsx, jsxs, Fragment } from \"react/jsx-runtime\";\nimport React, { createElement } from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return (arg) => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return (arg2) => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup(...args) {\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc(...procs) {\n  return () => {\n    procs.map(call);\n  };\n}\nfunction isDefined(arg) {\n  return arg !== void 0;\n}\nfunction noop() {\n}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, (value) => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach((subscription) => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), (stream2) => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n  return (subscriber) => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source, ...operators) {\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n  let current;\n  return (done) => (next) => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return (done) => (value) => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return (done) => compose(done, project);\n}\nfunction mapTo(value) {\n  return (done) => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return (done) => (value) => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return (done) => (value) => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue = null;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom(...sources) {\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return (done) => (value) => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge(...sources) {\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map((source) => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source, comparator = defaultComparator) {\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n  const innerSubject = stream();\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor, dependencies = [], { singleton } = { singleton: true }) {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */ new Map();\n  const _init = ({ id: id2, constructor, dependencies, singleton }) => {\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map((e) => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$1 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = (value) => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$1(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$1(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    const RootComponent = Root;\n    return /* @__PURE__ */ jsx(Context.Provider, { value: system2, children: Root ? /* @__PURE__ */ jsx(RootComponent, { ...omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props), children }) : children });\n  });\n  const usePublisher2 = (key) => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue18 = (key) => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const cb = React.useCallback(\n      (c) => {\n        return subscribe(source, c);\n      },\n      [source]\n    );\n    return React.useSyncExternalStore(\n      cb,\n      () => getValue(source),\n      () => getValue(source)\n    );\n  };\n  const useEmitterValueLegacy = (key) => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$1(\n      () => subscribe(source, (next) => {\n        if (next !== value) {\n          setValue(always(next));\n        }\n      }),\n      [source, value]\n    );\n    return value;\n  };\n  const useEmitterValue2 = React.version.startsWith(\"18\") ? useEmitterValue18 : useEmitterValueLegacy;\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$1(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [\n    0\n    /* DEBUG */\n  ]: \"debug\",\n  [\n    1\n    /* INFO */\n  ]: \"log\",\n  [\n    2\n    /* WARN */\n  ]: \"warn\",\n  [\n    3\n    /* ERROR */\n  ]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(\n  () => {\n    const logLevel = statefulStream(\n      3\n      /* ERROR */\n    );\n    const log = statefulStream((label, message, level = 1) => {\n      var _a;\n      const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n      if (level >= currentLevel) {\n        console[CONSOLE_METHOD_MAP[level]](\n          \"%creact-virtuoso: %c%s %o\",\n          \"color: #0253b3; font-weight: bold\",\n          \"color: initial\",\n          label,\n          message\n        );\n      }\n    });\n    return {\n      log,\n      logLevel\n    };\n  },\n  [],\n  { singleton: true }\n);\nfunction useSizeWithElRef(callback, enabled, skipAnimationFrame) {\n  const ref = React.useRef(null);\n  let callbackRef = (_el) => {\n  };\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = React.useMemo(() => {\n      return new ResizeObserver((entries) => {\n        const code = () => {\n          const element = entries[0].target;\n          if (element.offsetParent !== null) {\n            callback(element);\n          }\n        };\n        skipAnimationFrame ? code() : requestAnimationFrame(code);\n      });\n    }, [callback]);\n    callbackRef = (elRef) => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return { ref, callbackRef };\n}\nfunction useSize(callback, enabled, skipAnimationFrame) {\n  return useSizeWithElRef(callback, enabled, skipAnimationFrame).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent, horizontalDirection, skipAnimationFrame) {\n  const memoedCallback = React.useCallback(\n    (el) => {\n      const ranges = getChangedChildSizes(el.children, itemSize, horizontalDirection ? \"offsetWidth\" : \"offsetHeight\", log);\n      let scrollableElement = el.parentElement;\n      while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n        scrollableElement = scrollableElement.parentElement;\n      }\n      const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n      const scrollTop = customScrollParent ? horizontalDirection ? customScrollParent.scrollLeft : customScrollParent.scrollTop : windowScrolling ? horizontalDirection ? window.pageXOffset || document.documentElement.scrollLeft : window.pageYOffset || document.documentElement.scrollTop : horizontalDirection ? scrollableElement.scrollLeft : scrollableElement.scrollTop;\n      const scrollHeight = customScrollParent ? horizontalDirection ? customScrollParent.scrollWidth : customScrollParent.scrollHeight : windowScrolling ? horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight : horizontalDirection ? scrollableElement.scrollWidth : scrollableElement.scrollHeight;\n      const viewportHeight = customScrollParent ? horizontalDirection ? customScrollParent.offsetWidth : customScrollParent.offsetHeight : windowScrolling ? horizontalDirection ? window.innerWidth : window.innerHeight : horizontalDirection ? scrollableElement.offsetWidth : scrollableElement.offsetHeight;\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n      gap == null ? void 0 : gap(\n        horizontalDirection ? resolveGapValue$1(\"column-gap\", getComputedStyle(el).columnGap, log) : resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log)\n      );\n      if (ranges !== null) {\n        callback(ranges);\n      }\n    },\n    [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]\n  );\n  return useSizeWithElRef(memoedCallback, enabled, skipAnimationFrame);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", { child }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({ startIndex: index, endIndex: index, size });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent, horizontalDirection) {\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(\n    (ev) => {\n      const el = ev.target;\n      const windowScroll = el === window || el === document;\n      const scrollTop = horizontalDirection ? windowScroll ? window.pageXOffset || document.documentElement.scrollLeft : el.scrollLeft : windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n      const scrollHeight = horizontalDirection ? windowScroll ? document.documentElement.scrollWidth : el.scrollWidth : windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n      const viewportHeight = horizontalDirection ? windowScroll ? window.innerWidth : el.offsetWidth : windowScroll ? window.innerHeight : el.offsetHeight;\n      const call2 = () => {\n        scrollContainerStateCallback({\n          scrollTop: Math.max(scrollTop, 0),\n          scrollHeight,\n          viewportHeight\n        });\n      };\n      if (ev.suppressFlushSync) {\n        call2();\n      } else {\n        ReactDOM.flushSync(call2);\n      }\n      if (scrollTopTarget.current !== null) {\n        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n          scrollTopTarget.current = null;\n          smoothScrollTargetReached(true);\n          if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n          }\n        }\n      }\n    },\n    [scrollContainerStateCallback, smoothScrollTargetReached]\n  );\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({ target: localRef, suppressFlushSync: true });\n    localRef.addEventListener(\"scroll\", handler, { passive: true });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || (horizontalDirection ? \"offsetWidth\" in scrollerElement2 && scrollerElement2.offsetWidth === 0 : \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0)) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(\n        correctItemSize(document.documentElement, horizontalDirection ? \"width\" : \"height\"),\n        horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight\n      );\n      offsetHeight = horizontalDirection ? window.innerWidth : window.innerHeight;\n      scrollTop = horizontalDirection ? document.documentElement.scrollLeft : document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2[horizontalDirection ? \"scrollWidth\" : \"scrollHeight\"];\n      offsetHeight = correctItemSize(scrollerElement2, horizontalDirection ? \"width\" : \"height\");\n      scrollTop = scrollerElement2[horizontalDirection ? \"scrollLeft\" : \"scrollTop\"];\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    if (horizontalDirection) {\n      location = { left: location.top, behavior: location.behavior };\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    if (horizontalDirection) {\n      location = { left: location.top, behavior: location.behavior };\n    }\n    scrollerRef.current.scrollBy(location);\n  }\n  return { scrollerRef, scrollByCallback, scrollToCallback };\n}\nconst domIOSystem = system(\n  () => {\n    const scrollContainerState = stream();\n    const scrollTop = stream();\n    const deviation = statefulStream(0);\n    const smoothScrollTargetReached = stream();\n    const statefulScrollTop = statefulStream(0);\n    const viewportHeight = stream();\n    const scrollHeight = stream();\n    const headerHeight = statefulStream(0);\n    const fixedHeaderHeight = statefulStream(0);\n    const fixedFooterHeight = statefulStream(0);\n    const footerHeight = statefulStream(0);\n    const scrollTo = stream();\n    const scrollBy = stream();\n    const scrollingInProgress = statefulStream(false);\n    const horizontalDirection = statefulStream(false);\n    const skipAnimationFrameInResizeObserver = statefulStream(false);\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollTop: scrollTop2 }) => scrollTop2)\n      ),\n      scrollTop\n    );\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollHeight: scrollHeight2 }) => scrollHeight2)\n      ),\n      scrollHeight\n    );\n    connect(scrollTop, statefulScrollTop);\n    return {\n      // input\n      scrollContainerState,\n      scrollTop,\n      viewportHeight,\n      headerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight,\n      footerHeight,\n      scrollHeight,\n      smoothScrollTargetReached,\n      horizontalDirection,\n      skipAnimationFrameInResizeObserver,\n      // signals\n      scrollTo,\n      scrollBy,\n      // state\n      statefulScrollTop,\n      deviation,\n      scrollingInProgress\n    };\n  },\n  [],\n  { singleton: true }\n);\nconst NIL_NODE = { lvl: 0 };\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n  return { k, v, lvl, l, r };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node)) return NIL_NODE;\n  const { k, l, r } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, { k: lastKey, v: lastValue, l: deleteLast(l) }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, { l: remove(l, key) }));\n  } else {\n    return adjust(clone(node, { r: remove(r, key) }));\n  }\n}\nfunction find(node, key) {\n  if (empty(node)) {\n    return;\n  }\n  if (key === node.k) {\n    return node.v;\n  } else if (key < node.k) {\n    return find(node.l, key);\n  } else {\n    return find(node.r, key);\n  }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (Number(node[field]) === value) {\n    return [node.k, node.v];\n  }\n  if (Number(node[field]) < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, { k, v });\n  } else if (k < node.k) {\n    return rebalance(clone(node, { l: insert(node.l, k, v) }));\n  } else {\n    return rebalance(clone(node, { r: insert(node.r, k, v) }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const { k, v, l, r } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({ k, v });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, { r: deleteLast(node.r) }));\n}\nfunction clone(node, args) {\n  return newAANode(\n    args.k !== void 0 ? args.k : node.k,\n    args.v !== void 0 ? args.v : node.v,\n    args.lvl !== void 0 ? args.lvl : node.lvl,\n    args.l !== void 0 ? args.l : node.l,\n    args.r !== void 0 ? args.r : node.r\n  );\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const { l, r, lvl } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, { r: l.r.l }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, { l: rl.r, lvl: rlvl })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let { index: start, value } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const { index: nextIndex, value: nextValue } = parser(items[i]);\n    result.push({ start, end: nextIndex - 1, value });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({ start, end: Infinity, value });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, ({ k: index, v: value }) => ({ index, value }));\n}\nfunction split(node) {\n  const { r, lvl } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, { l: clone(node, { r: r.l }), lvl: lvl + 1 }) : node;\n}\nfunction skew(node) {\n  const { l } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, { r: clone(node, { l: l.r }) }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(\n  () => {\n    const recalcInProgress = statefulStream(false);\n    return { recalcInProgress };\n  },\n  [],\n  { singleton: true }\n);\nfunction rangeIncludes(refRange) {\n  const { size, startIndex, endIndex } = refRange;\n  return (range) => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n  let recognizedOffsetItems = 0;\n  let groupIndex = 0;\n  while (recognizedOffsetItems < offset) {\n    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n    groupIndex++;\n  }\n  const offsetIsExact = recognizedOffsetItems === offset;\n  return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const { size, startIndex, endIndex } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator({ index: itemIndex }, index) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({ offset: itemOffset }, offset) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return { index: point.index, value: point };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const { offset, index: startIndex, size } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n  return walk(sizeTree).map(({ k: startIndex, v: size }, index, sizeArray) => {\n    const nextSize = sizeArray[index + 1];\n    const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n    return { startIndex, endIndex, size };\n  });\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(\n  ([{ log }, { recalcInProgress }]) => {\n    const sizeRanges = stream();\n    const totalCount = stream();\n    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n    const unshiftWith = stream();\n    const shiftWith = stream();\n    const firstItemIndex = statefulStream(0);\n    const groupIndices = statefulStream([]);\n    const fixedItemSize = statefulStream(void 0);\n    const defaultItemSize = statefulStream(void 0);\n    const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n    const data = statefulStream(void 0);\n    const gap = statefulStream(0);\n    const initial = initialSizeState();\n    const sizes = statefulStreamFromEmitter(\n      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()),\n      initial\n    );\n    const prevGroupIndices = statefulStreamFromEmitter(\n      pipe(\n        groupIndices,\n        distinctUntilChanged(),\n        scan((prev, curr) => ({ prev: prev.current, current: curr }), {\n          prev: [],\n          current: []\n        }),\n        map(({ prev }) => prev)\n      ),\n      []\n    );\n    connect(\n      pipe(\n        groupIndices,\n        filter((indexes) => indexes.length > 0),\n        withLatestFrom(sizes, gap),\n        map(([groupIndices2, sizes2, gap2]) => {\n          const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n            return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n          }, newTree());\n          return {\n            ...sizes2,\n            groupIndices: groupIndices2,\n            groupOffsetTree\n          };\n        })\n      ),\n      sizes\n    );\n    connect(\n      pipe(\n        totalCount,\n        withLatestFrom(sizes),\n        filter(([totalCount2, { lastIndex }]) => {\n          return totalCount2 < lastIndex;\n        }),\n        map(([totalCount2, { lastIndex, lastSize }]) => {\n          return [\n            {\n              startIndex: totalCount2,\n              endIndex: lastIndex,\n              size: lastSize\n            }\n          ];\n        })\n      ),\n      sizeRanges\n    );\n    connect(fixedItemSize, defaultItemSize);\n    const trackItemSizes = statefulStreamFromEmitter(\n      pipe(\n        fixedItemSize,\n        map((size) => size === void 0)\n      ),\n      true\n    );\n    connect(\n      pipe(\n        defaultItemSize,\n        filter((value) => {\n          return value !== void 0 && empty(getValue(sizes).sizeTree);\n        }),\n        map((size) => [{ startIndex: 0, endIndex: 0, size }])\n      ),\n      sizeRanges\n    );\n    const listRefresh = streamFromEmitter(\n      pipe(\n        sizeRanges,\n        withLatestFrom(sizes),\n        scan(\n          ({ sizes: oldSizes }, [_, newSizes]) => {\n            return {\n              changed: newSizes !== oldSizes,\n              sizes: newSizes\n            };\n          },\n          { changed: false, sizes: initial }\n        ),\n        map((value) => value.changed)\n      )\n    );\n    subscribe(\n      pipe(\n        firstItemIndex,\n        scan(\n          (prev, next) => {\n            return { diff: prev.prev - next, prev: next };\n          },\n          { diff: 0, prev: 0 }\n        ),\n        map((val) => val.diff)\n      ),\n      (offset) => {\n        const { groupIndices: groupIndices2 } = getValue(sizes);\n        if (offset > 0) {\n          publish(recalcInProgress, true);\n          publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n        } else if (offset < 0) {\n          const prevGroupIndicesValue = getValue(prevGroupIndices);\n          if (prevGroupIndicesValue.length > 0) {\n            offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n          }\n          publish(shiftWith, offset);\n        }\n      }\n    );\n    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {\n      if (index < 0) {\n        log2(\n          \"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\",\n          { firstItemIndex },\n          LogLevel.ERROR\n        );\n      }\n    });\n    const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n    connect(\n      pipe(\n        unshiftWith,\n        withLatestFrom(sizes),\n        map(([unshiftWith2, sizes2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          const initialRanges = [];\n          const defaultSize = sizes2.lastSize;\n          if (groupedMode) {\n            const firstGroupSize = find(sizes2.sizeTree, 0);\n            let prependedGroupItemsCount = 0;\n            let groupIndex = 0;\n            while (prependedGroupItemsCount < unshiftWith2) {\n              const theGroupIndex = sizes2.groupIndices[groupIndex];\n              const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n              initialRanges.push({\n                startIndex: theGroupIndex,\n                endIndex: theGroupIndex,\n                size: firstGroupSize\n              });\n              initialRanges.push({\n                startIndex: theGroupIndex + 1,\n                endIndex: theGroupIndex + 1 + groupItemCount - 1,\n                size: defaultSize\n              });\n              groupIndex++;\n              prependedGroupItemsCount += groupItemCount + 1;\n            }\n            const sizeTreeKV = walk(sizes2.sizeTree);\n            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n            if (firstGroupIsExpanded) {\n              sizeTreeKV.shift();\n            }\n            return sizeTreeKV.reduce(\n              (acc, { k: index, v: size }) => {\n                let ranges = acc.ranges;\n                if (acc.prevSize !== 0) {\n                  ranges = [\n                    ...acc.ranges,\n                    {\n                      startIndex: acc.prevIndex,\n                      endIndex: index + unshiftWith2 - 1,\n                      size: acc.prevSize\n                    }\n                  ];\n                }\n                return {\n                  ranges,\n                  prevIndex: index + unshiftWith2,\n                  prevSize: size\n                };\n              },\n              {\n                ranges: initialRanges,\n                prevIndex: unshiftWith2,\n                prevSize: 0\n              }\n            ).ranges;\n          }\n          return walk(sizes2.sizeTree).reduce(\n            (acc, { k: index, v: size }) => {\n              return {\n                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index + unshiftWith2 - 1, size: acc.prevSize }],\n                prevIndex: index + unshiftWith2,\n                prevSize: size\n              };\n            },\n            {\n              ranges: [],\n              prevIndex: 0,\n              prevSize: defaultSize\n            }\n          ).ranges;\n        })\n      ),\n      sizeRanges\n    );\n    const shiftWithOffset = streamFromEmitter(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, { offsetTree }, gap2]) => {\n          const newFirstItemIndex = -shiftWith2;\n          return offsetOf(newFirstItemIndex, offsetTree, gap2);\n        })\n      )\n    );\n    connect(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, sizes2, gap2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          if (groupedMode) {\n            if (empty(sizes2.sizeTree)) {\n              return sizes2;\n            }\n            let newSizeTree = newTree();\n            const prevGroupIndicesValue = getValue(prevGroupIndices);\n            let removedItemsCount = 0;\n            let groupIndex = 0;\n            let groupOffset = 0;\n            while (removedItemsCount < -shiftWith2) {\n              groupOffset = prevGroupIndicesValue[groupIndex];\n              const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n              groupIndex++;\n              removedItemsCount += groupItemCount + 1;\n            }\n            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newSizeTree);\n            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n            if (aGroupIsShrunk) {\n              const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n              newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n              const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n              newSizeTree = insert(newSizeTree, 1, nextItemSize);\n            }\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          } else {\n            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newTree());\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          }\n        })\n      ),\n      sizes\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      sizeRanges,\n      groupIndices,\n      defaultItemSize,\n      fixedItemSize,\n      unshiftWith,\n      shiftWith,\n      shiftWithOffset,\n      beforeUnshiftWith,\n      firstItemIndex,\n      gap,\n      // output\n      sizes,\n      listRefresh,\n      statefulTotalCount,\n      trackItemSizes,\n      itemSize\n    };\n  },\n  tup(loggerSystem, recalcSystem),\n  { singleton: true }\n);\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? { index: location } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(\n  ([\n    { sizes, totalCount, listRefresh, gap },\n    {\n      scrollingInProgress,\n      viewportHeight,\n      scrollTo,\n      smoothScrollTargetReached,\n      headerHeight,\n      footerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight\n    },\n    { log }\n  ]) => {\n    const scrollToIndex = stream();\n    const scrollTargetReached = stream();\n    const topListHeight = statefulStream(0);\n    let unsubscribeNextListRefresh = null;\n    let cleartTimeoutRef = null;\n    let unsubscribeListRefresh = null;\n    function cleanup() {\n      if (unsubscribeNextListRefresh) {\n        unsubscribeNextListRefresh();\n        unsubscribeNextListRefresh = null;\n      }\n      if (unsubscribeListRefresh) {\n        unsubscribeListRefresh();\n        unsubscribeListRefresh = null;\n      }\n      if (cleartTimeoutRef) {\n        clearTimeout(cleartTimeoutRef);\n        cleartTimeoutRef = null;\n      }\n      publish(scrollingInProgress, false);\n    }\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),\n        withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight),\n        map(\n          ([\n            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],\n            gap2,\n            fixedHeaderHeight2,\n            fixedFooterHeight2\n          ]) => {\n            const normalLocation = normalizeIndexLocation(location);\n            const { align, behavior, offset } = normalLocation;\n            const lastIndex = totalCount2 - 1;\n            const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n            let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n            if (align === \"end\") {\n              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n              if (index === lastIndex) {\n                top += footerHeight2;\n              }\n            } else if (align === \"center\") {\n              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n            } else {\n              top -= topListHeight2;\n            }\n            if (offset) {\n              top += offset;\n            }\n            const retry = (listChanged) => {\n              cleanup();\n              if (listChanged) {\n                log2(\"retrying to scroll to\", { location }, LogLevel.DEBUG);\n                publish(scrollToIndex, location);\n              } else {\n                publish(scrollTargetReached, true);\n                log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n              }\n            };\n            cleanup();\n            if (behavior === \"smooth\") {\n              let listChanged = false;\n              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {\n                listChanged = listChanged || changed;\n              });\n              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n                retry(listChanged);\n              });\n            } else {\n              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n            }\n            cleartTimeoutRef = setTimeout(() => {\n              cleanup();\n            }, 1200);\n            publish(scrollingInProgress, true);\n            log2(\"scrolling from index to\", { index, top, behavior }, LogLevel.DEBUG);\n            return { top, behavior };\n          }\n        )\n      ),\n      scrollTo\n    );\n    return {\n      scrollToIndex,\n      scrollTargetReached,\n      topListHeight\n    };\n  },\n  tup(sizeSystem, domIOSystem, loggerSystem),\n  { singleton: true }\n);\nfunction watchChangesFor(limit) {\n  return (done) => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return (value) => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(\n    pipe(\n      merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),\n      distinctUntilChanged()\n    ),\n    false\n  );\n  const isScrollingBy = statefulStreamFromEmitter(\n    pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),\n    false\n  );\n  connect(\n    pipe(\n      combineLatest(duc(scrollTop), duc(atTopThreshold)),\n      map(([top, atTopThreshold2]) => top <= atTopThreshold2),\n      distinctUntilChanged()\n    ),\n    isAtTop\n  );\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(\n    pipe(\n      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),\n      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {\n        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n        const state = {\n          viewportHeight: viewportHeight2,\n          scrollTop: scrollTop2,\n          scrollHeight\n        };\n        if (isAtBottom2) {\n          let atBottomBecause;\n          let scrollTopDelta;\n          if (scrollTop2 > current.state.scrollTop) {\n            atBottomBecause = \"SCROLLED_DOWN\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2;\n          } else {\n            atBottomBecause = \"SIZE_DECREASED\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n          }\n          return {\n            atBottom: true,\n            state,\n            atBottomBecause,\n            scrollTopDelta\n          };\n        }\n        let notAtBottomBecause;\n        if (state.scrollHeight > current.state.scrollHeight) {\n          notAtBottomBecause = \"SIZE_INCREASED\";\n        } else if (viewportHeight2 < current.state.viewportHeight) {\n          notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n        } else if (scrollTop2 < current.state.scrollTop) {\n          notAtBottomBecause = \"SCROLLING_UPWARDS\";\n        } else {\n          notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n        }\n        return {\n          atBottom: false,\n          notAtBottomBecause,\n          state\n        };\n      }, INITIAL_BOTTOM_STATE),\n      distinctUntilChanged((prev, next) => {\n        return prev && prev.atBottom === next.atBottom;\n      })\n    )\n  );\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(\n    pipe(\n      scrollContainerState,\n      scan(\n        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {\n          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n            if (current.scrollTop !== scrollTop2 && atBottom) {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: current.scrollTop - scrollTop2,\n                changed: true\n              };\n            } else {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: 0,\n                changed: true\n              };\n            }\n          } else {\n            return {\n              scrollTop: scrollTop2,\n              scrollHeight,\n              jump: 0,\n              changed: false\n            };\n          }\n        },\n        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }\n      ),\n      filter((value) => value.changed),\n      map((value) => value.jump)\n    ),\n    0\n  );\n  connect(\n    pipe(\n      atBottomState,\n      map((state) => state.atBottom)\n    ),\n    isAtBottom\n  );\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(\n    pipe(\n      scrollContainerState,\n      map(({ scrollTop: scrollTop2 }) => scrollTop2),\n      distinctUntilChanged(),\n      scan(\n        (acc, scrollTop2) => {\n          if (getValue(isScrollingBy)) {\n            return { direction: acc.direction, prevScrollTop: scrollTop2 };\n          }\n          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };\n        },\n        { direction: DOWN, prevScrollTop: 0 }\n      ),\n      map((value) => value.direction)\n    ),\n    scrollDirection\n  );\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(\n    pipe(\n      isScrolling,\n      filter((value) => !value),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      mapTo(0)\n    ),\n    scrollVelocity\n  );\n  connect(\n    pipe(\n      scrollTop,\n      throttleTime(100),\n      withLatestFrom(isScrolling),\n      filter(([_, isScrolling2]) => !!isScrolling2),\n      scan(([_, prev], [next]) => [prev, next], [0, 0]),\n      map(([prev, next]) => next - prev)\n    ),\n    scrollVelocity\n  );\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(\n  ([{ log }]) => {\n    const propsReady = statefulStream(false);\n    const didMount = streamFromEmitter(\n      pipe(\n        propsReady,\n        filter((ready) => ready),\n        distinctUntilChanged()\n      )\n    );\n    subscribe(propsReady, (value) => {\n      value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n    });\n    return { propsReady, didMount };\n  },\n  tup(loggerSystem),\n  { singleton: true }\n);\nfunction skipFrames(frameCount, callback) {\n  if (frameCount == 0) {\n    callback();\n  } else {\n    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));\n  }\n}\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nconst initialTopMostItemIndexSystem = system(\n  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex, scrollTargetReached }, { didMount }]) => {\n    const scrolledToInitialItem = statefulStream(true);\n    const initialTopMostItemIndex = statefulStream(0);\n    const initialItemFinalLocationReached = statefulStream(true);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location),\n        mapTo(false)\n      ),\n      scrolledToInitialItem\n    );\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location),\n        mapTo(false)\n      ),\n      initialItemFinalLocationReached\n    );\n    subscribe(\n      pipe(\n        combineLatest(listRefresh, didMount),\n        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, initialItemFinalLocationReached),\n        filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled]) => {\n          return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled;\n        }),\n        withLatestFrom(initialTopMostItemIndex)\n      ),\n      ([, initialTopMostItemIndex2]) => {\n        handleNext(scrollTargetReached, () => {\n          publish(initialItemFinalLocationReached, true);\n        });\n        skipFrames(4, () => {\n          handleNext(scrollTop, () => {\n            publish(scrolledToInitialItem, true);\n          });\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n      }\n    );\n    return {\n      scrolledToInitialItem,\n      initialTopMostItemIndex,\n      initialItemFinalLocationReached\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),\n  { singleton: true }\n);\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(\n  ([\n    { totalCount, listRefresh },\n    { isAtBottom, atBottomState },\n    { scrollToIndex },\n    { scrolledToInitialItem },\n    { propsReady, didMount },\n    { log },\n    { scrollingInProgress }\n  ]) => {\n    const followOutput = statefulStream(false);\n    const autoscrollToBottom = stream();\n    let pendingScrollHandle = null;\n    function scrollToBottom(followOutputBehavior) {\n      publish(scrollToIndex, {\n        index: \"LAST\",\n        align: \"end\",\n        behavior: followOutputBehavior\n      });\n    }\n    subscribe(\n      pipe(\n        combineLatest(pipe(duc(totalCount), skip(1)), didMount),\n        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),\n        map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {\n          let shouldFollow = didMount2 && scrolledToInitialItem2;\n          let followOutputBehavior = \"auto\";\n          if (shouldFollow) {\n            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n            shouldFollow = shouldFollow && !!followOutputBehavior;\n          }\n          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };\n        }),\n        filter(({ shouldFollow }) => shouldFollow)\n      ),\n      ({ totalCount: totalCount2, followOutputBehavior }) => {\n        if (pendingScrollHandle) {\n          pendingScrollHandle();\n          pendingScrollHandle = null;\n        }\n        pendingScrollHandle = handleNext(listRefresh, () => {\n          getValue(log)(\"following output to \", { totalCount: totalCount2 }, LogLevel.DEBUG);\n          scrollToBottom(followOutputBehavior);\n          pendingScrollHandle = null;\n        });\n      }\n    );\n    function trapNextSizeIncrease(followOutput2) {\n      const cancel = handleNext(atBottomState, (state) => {\n        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n          getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n          scrollToBottom(\"auto\");\n        }\n      });\n      setTimeout(cancel, 100);\n    }\n    subscribe(\n      pipe(\n        combineLatest(duc(followOutput), totalCount, propsReady),\n        filter(([follow, , ready]) => follow && ready),\n        scan(\n          ({ value }, [, next]) => {\n            return { refreshed: value === next, value: next };\n          },\n          { refreshed: false, value: 0 }\n        ),\n        filter(({ refreshed }) => refreshed),\n        withLatestFrom(followOutput, totalCount)\n      ),\n      ([, followOutput2]) => {\n        if (getValue(scrolledToInitialItem)) {\n          trapNextSizeIncrease(followOutput2 !== false);\n        }\n      }\n    );\n    subscribe(autoscrollToBottom, () => {\n      trapNextSizeIncrease(getValue(followOutput) !== false);\n    });\n    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n        scrollToBottom(\"auto\");\n      }\n    });\n    return { followOutput, autoscrollToBottom };\n  },\n  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)\n);\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce(\n    (acc, groupCount) => {\n      acc.groupIndices.push(acc.totalCount);\n      acc.totalCount += groupCount + 1;\n      return acc;\n    },\n    {\n      totalCount: 0,\n      groupIndices: []\n    }\n  );\n}\nconst groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.totalCount)\n    ),\n    totalCount\n  );\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.groupIndices)\n    ),\n    groupIndices\n  );\n  connect(\n    pipe(\n      combineLatest(scrollTop, sizes, headerHeight),\n      filter(([_, sizes2]) => hasGroups(sizes2)),\n      map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]),\n      distinctUntilChanged(),\n      map((index) => [index])\n    ),\n    topItemsIndexes\n  );\n  return { groupCounts, topItemsIndexes };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(\n  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {\n    const listBoundary = stream();\n    const topListHeight = statefulStream(0);\n    const increaseViewportBy = statefulStream(0);\n    const overscan = statefulStream(0);\n    const visibleRange = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          duc(scrollTop),\n          duc(viewportHeight),\n          duc(headerHeight),\n          duc(listBoundary, tupleComparator),\n          duc(overscan),\n          duc(topListHeight),\n          duc(fixedHeaderHeight),\n          duc(deviation),\n          duc(increaseViewportBy)\n        ),\n        map(\n          ([\n            scrollTop2,\n            viewportHeight2,\n            headerHeight2,\n            [listTop, listBottom],\n            overscan2,\n            topListHeight2,\n            fixedHeaderHeight2,\n            deviation2,\n            increaseViewportBy2\n          ]) => {\n            const top = scrollTop2 - deviation2;\n            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n            const headerVisible = Math.max(headerHeight2 - top, 0);\n            let direction = NONE;\n            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n            listTop -= deviation2;\n            listTop += headerHeight2 + fixedHeaderHeight2;\n            listBottom += headerHeight2 + fixedHeaderHeight2;\n            listBottom -= deviation2;\n            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n              direction = UP;\n            }\n            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n              direction = DOWN;\n            }\n            if (direction !== NONE) {\n              return [\n                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),\n                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition\n              ];\n            }\n            return null;\n          }\n        ),\n        filter((value) => value != null),\n        distinctUntilChanged(tupleComparator)\n      ),\n      [0, 0]\n    );\n    return {\n      // input\n      listBoundary,\n      overscan,\n      topListHeight,\n      increaseViewportBy,\n      // output\n      visibleRange\n    };\n  },\n  tup(domIOSystem),\n  { singleton: true }\n);\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [\n      { index: groupIndex, size: 0, offset: 0 },\n      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }\n    ];\n  }\n  return [{ index, size: 0, offset: 0, data: data && data[0] }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const { lastSize, lastOffset, lastIndex } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nfunction buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap, data) {\n  let includedGroupsCount = 0;\n  if (sizes.groupIndices.length > 0) {\n    for (const index of sizes.groupIndices) {\n      if (index - includedGroupsCount >= itemCount) {\n        break;\n      }\n      includedGroupsCount++;\n    }\n  }\n  const adjustedCount = itemCount + includedGroupsCount;\n  const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);\n  const items = Array.from({ length: adjustedCount }).map((_, index) => ({\n    index: index + initialTopMostItemIndexNumber,\n    size: 0,\n    offset: 0,\n    data: data[index + initialTopMostItemIndexNumber]\n  }));\n  return buildListState(items, [], adjustedCount, gap, sizes, firstItemIndex);\n}\nconst listStateSystem = system(\n  ([\n    { sizes, totalCount, data, firstItemIndex, gap },\n    groupedListSystem2,\n    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },\n    { scrolledToInitialItem, initialTopMostItemIndex },\n    { topListHeight },\n    stateFlags,\n    { didMount },\n    { recalcInProgress }\n  ]) => {\n    const topItemsIndexes = statefulStream([]);\n    const initialItemCount = statefulStream(0);\n    const itemsRendered = stream();\n    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n    const listState = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          didMount,\n          recalcInProgress,\n          duc(visibleRange, tupleComparator),\n          duc(totalCount),\n          duc(sizes),\n          duc(initialTopMostItemIndex),\n          scrolledToInitialItem,\n          duc(topItemsIndexes),\n          duc(firstItemIndex),\n          duc(gap),\n          data\n        ),\n        filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {\n          const dataChangeInProgress = data2 && data2.length !== totalCount2;\n          return mount && !recalcInProgress2 && !dataChangeInProgress;\n        }),\n        map(\n          ([\n            ,\n            ,\n            [startOffset, endOffset],\n            totalCount2,\n            sizes2,\n            initialTopMostItemIndex2,\n            scrolledToInitialItem2,\n            topItemsIndexes2,\n            firstItemIndex2,\n            gap2,\n            data2\n          ]) => {\n            const sizesValue = sizes2;\n            const { sizeTree, offsetTree } = sizesValue;\n            const initialItemCountValue = getValue(initialItemCount);\n            if (totalCount2 === 0) {\n              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };\n            }\n            if (startOffset === 0 && endOffset === 0) {\n              if (initialItemCountValue === 0) {\n                return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };\n              } else {\n                return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap2, data2 || []);\n              }\n            }\n            if (empty(sizeTree)) {\n              if (initialItemCountValue > 0) {\n                return null;\n              }\n              const state = buildListState(\n                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),\n                [],\n                totalCount2,\n                gap2,\n                sizesValue,\n                firstItemIndex2\n              );\n              return state;\n            }\n            const topItems = [];\n            if (topItemsIndexes2.length > 0) {\n              const startIndex = topItemsIndexes2[0];\n              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n              let offset = 0;\n              for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n                const size = range.value;\n                const rangeStartIndex = Math.max(range.start, startIndex);\n                const rangeEndIndex = Math.min(range.end, endIndex);\n                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n                  topItems.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size;\n                }\n              }\n            }\n            if (!scrolledToInitialItem2) {\n              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n            }\n            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n            if (offsetPointRanges.length === 0) {\n              return null;\n            }\n            const maxIndex = totalCount2 - 1;\n            const items = tap([], (result) => {\n              for (const range of offsetPointRanges) {\n                const point = range.value;\n                let offset = point.offset;\n                let rangeStartIndex = range.start;\n                const size = point.size;\n                if (point.offset < startOffset) {\n                  rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n                  const itemCount = rangeStartIndex - range.start;\n                  offset += itemCount * size + itemCount * gap2;\n                }\n                if (rangeStartIndex < minStartIndex) {\n                  offset += (minStartIndex - rangeStartIndex) * size;\n                  rangeStartIndex = minStartIndex;\n                }\n                const endIndex = Math.min(range.end, maxIndex);\n                for (let i = rangeStartIndex; i <= endIndex; i++) {\n                  if (offset >= endOffset) {\n                    break;\n                  }\n                  result.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size + gap2;\n                }\n              }\n            });\n            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n          }\n        ),\n        //@ts-expect-error filter needs to be fixed\n        filter((value) => value !== null),\n        distinctUntilChanged()\n      ),\n      EMPTY_LIST_STATE\n    );\n    connect(\n      pipe(\n        data,\n        filter(isDefined),\n        map((data2) => data2 == null ? void 0 : data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        listState,\n        map((value) => value.topListHeight)\n      ),\n      topListHeight\n    );\n    connect(topListHeight, rangeTopListHeight);\n    connect(\n      pipe(\n        listState,\n        map((state) => [state.top, state.bottom])\n      ),\n      listBoundary\n    );\n    connect(\n      pipe(\n        listState,\n        map((state) => state.items)\n      ),\n      itemsRendered\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, data),\n        filter(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),\n        map(([, totalCount2, data2]) => [totalCount2 - 1, data2]),\n        distinctUntilChanged(tupleComparator),\n        map(([count]) => count)\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        listState,\n        throttleTime(200),\n        filter(({ items, topItems }) => {\n          return items.length > 0 && items[0].originalIndex === topItems.length;\n        }),\n        map(({ items }) => items[0].index),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        map(({ items }) => {\n          let startIndex = 0;\n          let endIndex = items.length - 1;\n          while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n            startIndex++;\n          }\n          while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n            endIndex--;\n          }\n          return {\n            startIndex: items[startIndex].index,\n            endIndex: items[endIndex].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator)\n      )\n    );\n    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, initialItemCount, ...stateFlags };\n  },\n  tup(\n    sizeSystem,\n    groupedListSystem,\n    sizeRangeSystem,\n    initialTopMostItemIndexSystem,\n    scrollToIndexSystem,\n    stateFlagsSystem,\n    propsReadySystem,\n    recalcSystem\n  ),\n  { singleton: true }\n);\nconst initialItemCountSystem = system(\n  ([{ sizes, firstItemIndex, data, gap }, { initialTopMostItemIndex }, { initialItemCount, listState }, { didMount }]) => {\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialItemCount),\n        filter(([, count]) => count !== 0),\n        withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap, data),\n        map(([[, count], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2 = []]) => {\n          return buildListStateFromItemCount(count, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2);\n        })\n      ),\n      listState\n    );\n    return {};\n  },\n  tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem),\n  { singleton: true }\n);\nconst scrollSeekSystem = system(\n  ([{ scrollVelocity }]) => {\n    const isSeeking = statefulStream(false);\n    const rangeChanged = stream();\n    const scrollSeekConfiguration = statefulStream(false);\n    connect(\n      pipe(\n        scrollVelocity,\n        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),\n        filter(([_, config]) => !!config),\n        map(([speed, config, isSeeking2, range]) => {\n          const { exit, enter } = config;\n          if (isSeeking2) {\n            if (exit(speed, range)) {\n              return false;\n            }\n          } else {\n            if (enter(speed, range)) {\n              return true;\n            }\n          }\n          return isSeeking2;\n        }),\n        distinctUntilChanged()\n      ),\n      isSeeking\n    );\n    subscribe(\n      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),\n      ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range)\n    );\n    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };\n  },\n  tup(stateFlagsSystem),\n  { singleton: true }\n);\nconst topItemCountSystem = system(([{ topItemsIndexes }]) => {\n  const topItemCount = statefulStream(0);\n  connect(\n    pipe(\n      topItemCount,\n      filter((length) => length >= 0),\n      map((length) => Array.from({ length }).map((_, index) => index))\n    ),\n    topItemsIndexes\n  );\n  return { topItemCount };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(\n  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {\n    const totalListHeightChanged = stream();\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),\n        map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {\n          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(duc(totalListHeight), totalListHeightChanged);\n    return { totalListHeight, totalListHeightChanged };\n  },\n  tup(domIOSystem, listStateSystem),\n  { singleton: true }\n);\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(\n  ([\n    { scrollBy, scrollTop, deviation, scrollingInProgress },\n    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },\n    { listState },\n    { beforeUnshiftWith, shiftWithOffset, sizes, gap },\n    { log },\n    { recalcInProgress }\n  ]) => {\n    const deviationOffset = streamFromEmitter(\n      pipe(\n        listState,\n        withLatestFrom(lastJumpDueToItemResize),\n        scan(\n          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2]) => {\n            const totalHeight = bottom + offsetBottom;\n            let newDev = 0;\n            if (prevTotalCount === totalCount) {\n              if (prevItems.length > 0 && items.length > 0) {\n                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n                if (!atStart) {\n                  newDev = totalHeight - prevTotalHeight;\n                  if (newDev !== 0) {\n                    newDev += lastJumpDueToItemResize2;\n                  }\n                }\n              }\n            }\n            return [newDev, items, totalCount, totalHeight];\n          },\n          [0, [], 0, 0]\n        ),\n        filter(([amount]) => amount !== 0),\n        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress),\n        filter(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2]) => {\n          return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n        }),\n        map(([[amount], , , , , log2]) => {\n          log2(\"Upward scrolling compensation\", { amount }, LogLevel.DEBUG);\n          return amount;\n        })\n      )\n    );\n    function scrollByWith(offset) {\n      if (offset > 0) {\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n        publish(deviation, 0);\n      } else {\n        publish(deviation, 0);\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n      }\n    }\n    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {\n      if (isScrolling2 && isMobileSafari()) {\n        publish(deviation, deviationAmount - offset);\n      } else {\n        scrollByWith(-offset);\n      }\n    });\n    subscribe(\n      pipe(\n        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),\n        filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0),\n        map(([_, deviation2]) => deviation2),\n        throttleTime(1)\n      ),\n      scrollByWith\n    );\n    connect(\n      pipe(\n        shiftWithOffset,\n        map((offset) => {\n          return { top: -offset };\n        })\n      ),\n      scrollBy\n    );\n    subscribe(\n      pipe(\n        beforeUnshiftWith,\n        withLatestFrom(sizes, gap),\n        map(([offset, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap2]) => {\n          function getItemOffset(itemCount) {\n            return itemCount * (defaultItemSize + gap2);\n          }\n          if (groupIndices.length === 0) {\n            return getItemOffset(offset);\n          } else {\n            let amount = 0;\n            const defaultGroupSize = find(sizeTree, 0);\n            let recognizedOffsetItems = 0;\n            let groupIndex = 0;\n            while (recognizedOffsetItems < offset) {\n              recognizedOffsetItems++;\n              amount += defaultGroupSize;\n              let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n              if (recognizedOffsetItems + groupItemCount > offset) {\n                amount -= defaultGroupSize;\n                groupItemCount = offset - recognizedOffsetItems + 1;\n              }\n              recognizedOffsetItems += groupItemCount;\n              amount += getItemOffset(groupItemCount);\n              groupIndex++;\n            }\n            return amount;\n          }\n        })\n      ),\n      (offset) => {\n        publish(deviation, offset);\n        requestAnimationFrame(() => {\n          publish(scrollBy, { top: offset });\n          requestAnimationFrame(() => {\n            publish(deviation, 0);\n            publish(recalcInProgress, false);\n          });\n        });\n      }\n    );\n    return { deviation };\n  },\n  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)\n);\nconst initialScrollTopSystem = system(\n  ([{ didMount }, { scrollTo }, { listState }]) => {\n    const initialScrollTop = statefulStream(0);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialScrollTop),\n        filter(([, offset]) => offset !== 0),\n        map(([, offset]) => ({ top: offset }))\n      ),\n      (location) => {\n        handleNext(\n          pipe(\n            listState,\n            skip(1),\n            filter((state) => state.items.length > 1)\n          ),\n          () => {\n            requestAnimationFrame(() => {\n              publish(scrollTo, location);\n            });\n          }\n        );\n      }\n    );\n    return {\n      initialScrollTop\n    };\n  },\n  tup(propsReadySystem, domIOSystem, listStateSystem),\n  { singleton: true }\n);\nconst alignToBottomSystem = system(\n  ([{ viewportHeight }, { totalListHeight }]) => {\n    const alignToBottom = statefulStream(false);\n    const paddingTopAddition = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(alignToBottom, viewportHeight, totalListHeight),\n        filter(([enabled]) => enabled),\n        map(([, viewportHeight2, totalListHeight2]) => {\n          return Math.max(0, viewportHeight2 - totalListHeight2);\n        }),\n        throttleTime(0),\n        distinctUntilChanged()\n      ),\n      0\n    );\n    return { alignToBottom, paddingTopAddition };\n  },\n  tup(domIOSystem, totalListHeightSystem),\n  { singleton: true }\n);\nconst windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(\n    pipe(\n      combineLatest(windowScrollContainerState, windowViewportRect),\n      map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {\n        return {\n          scrollTop: Math.max(0, windowScrollTop - offsetTop),\n          scrollHeight,\n          viewportHeight\n        };\n      })\n    ),\n    scrollContainerState\n  );\n  connect(\n    pipe(\n      scrollTo,\n      withLatestFrom(windowViewportRect),\n      map(([scrollTo2, { offsetTop }]) => {\n        return {\n          ...scrollTo2,\n          top: scrollTo2.top + offsetTop\n        };\n      })\n    ),\n    windowScrollTo\n  );\n  return {\n    // config\n    useWindowScroll,\n    customScrollParent,\n    // input\n    windowScrollContainerState,\n    windowViewportRect,\n    // signals\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = ({\n  itemTop: itemTop2,\n  itemBottom,\n  viewportTop,\n  viewportBottom,\n  locationParams: { behavior, align, ...rest }\n}) => {\n  if (itemTop2 < viewportTop) {\n    return { ...rest, behavior, align: align != null ? align : \"start\" };\n  }\n  if (itemBottom > viewportBottom) {\n    return { ...rest, behavior, align: align != null ? align : \"end\" };\n  }\n  return null;\n};\nconst scrollIntoViewSystem = system(\n  ([\n    { sizes, totalCount, gap },\n    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },\n    { scrollToIndex }\n  ]) => {\n    const scrollIntoView = stream();\n    connect(\n      pipe(\n        scrollIntoView,\n        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),\n        withLatestFrom(gap),\n        map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {\n          const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest } = viewLocation;\n          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n          const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n          const viewportTop = scrollTop2 + fixedHeaderHeight2;\n          const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n          const location = calculateViewLocation({\n            itemTop: itemTop2,\n            itemBottom,\n            viewportTop,\n            viewportBottom,\n            locationParams: { behavior, align, ...rest }\n          });\n          if (location) {\n            done && handleNext(\n              pipe(\n                scrollingInProgress,\n                filter((value) => value === false),\n                // skips the initial publish of false, and the cleanup call.\n                // but if scrollingInProgress is true, we skip the initial publish.\n                skip(getValue(scrollingInProgress) ? 1 : 2)\n              ),\n              done\n            );\n          } else {\n            done && done();\n          }\n          return location;\n        }),\n        filter((value) => value !== null)\n      ),\n      scrollToIndex\n    );\n    return {\n      scrollIntoView\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),\n  { singleton: true }\n);\nconst stateLoadSystem = system(\n  ([\n    { sizes, sizeRanges },\n    { scrollTop, headerHeight },\n    { initialTopMostItemIndex },\n    { didMount },\n    { useWindowScroll, windowScrollContainerState, windowViewportRect }\n  ]) => {\n    const getState = stream();\n    const restoreStateFrom = statefulStream(void 0);\n    const statefulWindowScrollContainerState = statefulStream(null);\n    const statefulWindowViewportRect = statefulStream(null);\n    connect(windowScrollContainerState, statefulWindowScrollContainerState);\n    connect(windowViewportRect, statefulWindowViewportRect);\n    subscribe(\n      pipe(\n        getState,\n        withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect, headerHeight)\n      ),\n      ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2, headerHeight2]) => {\n        const ranges = sizeTreeToRanges(sizes2.sizeTree);\n        if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {\n          scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;\n        }\n        scrollTop2 -= headerHeight2;\n        callback({ ranges, scrollTop: scrollTop2 });\n      }\n    );\n    connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(restoreStateFrom),\n        filter(([, state]) => state !== void 0),\n        distinctUntilChanged(),\n        map(([, snapshot]) => {\n          return snapshot.ranges;\n        })\n      ),\n      sizeRanges\n    );\n    return {\n      getState,\n      restoreStateFrom\n    };\n  },\n  tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem)\n);\nfunction locationFromSnapshot(snapshot) {\n  return { offset: snapshot.scrollTop, index: 0, align: \"start\" };\n}\nconst featureGroup1System = system(\n  ([\n    sizeRange,\n    initialItemCount,\n    propsReady,\n    scrollSeek,\n    totalListHeight,\n    initialScrollTopSystem2,\n    alignToBottom,\n    windowScroller,\n    scrollIntoView,\n    logger\n  ]) => {\n    return {\n      ...sizeRange,\n      ...initialItemCount,\n      ...propsReady,\n      ...scrollSeek,\n      ...totalListHeight,\n      ...initialScrollTopSystem2,\n      ...alignToBottom,\n      ...windowScroller,\n      ...scrollIntoView,\n      ...logger\n    };\n  },\n  tup(\n    sizeRangeSystem,\n    initialItemCountSystem,\n    propsReadySystem,\n    scrollSeekSystem,\n    totalListHeightSystem,\n    initialScrollTopSystem,\n    alignToBottomSystem,\n    windowScrollerSystem,\n    scrollIntoViewSystem,\n    loggerSystem\n  )\n);\nconst listSystem = system(\n  ([\n    {\n      totalCount,\n      sizeRanges,\n      fixedItemSize,\n      defaultItemSize,\n      trackItemSizes,\n      itemSize,\n      data,\n      firstItemIndex,\n      groupIndices,\n      statefulTotalCount,\n      gap,\n      sizes\n    },\n    { initialTopMostItemIndex, scrolledToInitialItem, initialItemFinalLocationReached },\n    domIO,\n    stateLoad,\n    followOutput,\n    { listState, topItemsIndexes, ...flags },\n    { scrollToIndex },\n    _,\n    { topItemCount },\n    { groupCounts },\n    featureGroup1\n  ]) => {\n    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        featureGroup1.windowViewportRect,\n        map((value) => value.visibleHeight)\n      ),\n      domIO.viewportHeight\n    );\n    return {\n      // input\n      totalCount,\n      data,\n      firstItemIndex,\n      sizeRanges,\n      initialTopMostItemIndex,\n      scrolledToInitialItem,\n      initialItemFinalLocationReached,\n      topItemsIndexes,\n      topItemCount,\n      groupCounts,\n      fixedItemHeight: fixedItemSize,\n      defaultItemHeight: defaultItemSize,\n      gap,\n      ...followOutput,\n      // output\n      statefulTotalCount,\n      listState,\n      scrollToIndex,\n      trackItemSizes,\n      itemSize,\n      groupIndices,\n      // exported from stateFlagsSystem\n      ...flags,\n      // the bag of IO from featureGroup1System\n      ...featureGroup1,\n      ...domIO,\n      sizes,\n      ...stateLoad\n    };\n  },\n  tup(\n    sizeSystem,\n    initialTopMostItemIndexSystem,\n    domIOSystem,\n    stateLoadSystem,\n    followOutputSystem,\n    listStateSystem,\n    scrollToIndexSystem,\n    upwardScrollFixSystem,\n    topItemCountSystem,\n    groupedListSystem,\n    featureGroup1System\n  )\n);\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent, skipAnimationFrame) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(\n    (element) => {\n      if (element === null || !element.offsetParent) {\n        return;\n      }\n      const rect = element.getBoundingClientRect();\n      const visibleWidth = rect.width;\n      let visibleHeight, offsetTop;\n      if (customScrollParent) {\n        const customScrollParentRect = customScrollParent.getBoundingClientRect();\n        const deltaTop = rect.top - customScrollParentRect.top;\n        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n        offsetTop = deltaTop + customScrollParent.scrollTop;\n      } else {\n        visibleHeight = window.innerHeight - Math.max(0, rect.top);\n        offsetTop = rect.top + window.pageYOffset;\n      }\n      viewportInfo.current = {\n        offsetTop,\n        visibleHeight,\n        visibleWidth\n      };\n      callback(viewportInfo.current);\n    },\n    [callback, customScrollParent]\n  );\n  const { callbackRef, ref } = useSizeWithElRef(calculateInfo, true, skipAnimationFrame);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(() => {\n        requestAnimationFrame(scrollAndResizeEventHandler);\n      });\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream((index) => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const HeaderFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    HeaderFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({ height }) => /* @__PURE__ */ jsx(\"div\", { style: { height } });\nconst GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1, overflowAnchor: \"none\" };\nconst ITEM_STYLE$1 = { overflowAnchor: \"none\" };\nconst HORIZONTAL_ITEM_STYLE = { ...ITEM_STYLE$1, display: \"inline-block\", height: \"100%\" };\nconst Items$1 = /* @__PURE__ */ React.memo(function VirtuosoItems({ showTopList = false }) {\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const horizontalDirection = useEmitterValue$2(\"horizontalDirection\");\n  const { callbackRef } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    showTopList ? noop : scrollContainerStateCallback,\n    log,\n    listGap,\n    customScrollParent,\n    horizontalDirection,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", (value) => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  const initialItemFinalLocationReached = useEmitterValue$2(\"initialItemFinalLocationReached\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    ...horizontalDirection ? {\n      whiteSpace: \"nowrap\",\n      display: \"inline-block\",\n      height: \"100%\",\n      paddingLeft: listState.offsetTop,\n      paddingRight: listState.offsetBottom,\n      marginLeft: deviation !== 0 ? deviation : alignToBottom ? \"auto\" : 0\n    } : {\n      marginTop: deviation !== 0 ? deviation : alignToBottom ? \"auto\" : 0,\n      paddingTop: listState.offsetTop,\n      paddingBottom: listState.offsetBottom\n    },\n    ...initialItemFinalLocationReached ? {} : { visibility: \"hidden\" }\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return /* @__PURE__ */ jsx(EmptyPlaceholder, { ...contextPropIfNotDomElement(EmptyPlaceholder, context) });\n  }\n  return /* @__PURE__ */ jsx(\n    ListComponent,\n    {\n      ...contextPropIfNotDomElement(ListComponent, context),\n      ref: callbackRef,\n      style: containerStyle,\n      \"data-testid\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\",\n      children: (showTopList ? listState.topItems : listState.items).map((item) => {\n        const index = item.originalIndex;\n        const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n        if (isSeeking) {\n          return /* @__PURE__ */ createElement(\n            ScrollSeekPlaceholder,\n            {\n              ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n              key,\n              index: item.index,\n              height: item.size,\n              type: item.type || \"item\",\n              ...item.type === \"group\" ? {} : { groupIndex: item.groupIndex }\n            }\n          );\n        }\n        if (item.type === \"group\") {\n          return /* @__PURE__ */ createElement(\n            GroupComponent,\n            {\n              ...contextPropIfNotDomElement(GroupComponent, context),\n              key,\n              \"data-index\": index,\n              \"data-known-size\": item.size,\n              \"data-item-index\": item.index,\n              style: GROUP_STYLE\n            },\n            groupContent(item.index, context)\n          );\n        } else {\n          return /* @__PURE__ */ createElement(\n            ItemComponent,\n            {\n              ...contextPropIfNotDomElement(ItemComponent, context),\n              ...itemPropIfNotDomElement(ItemComponent, item.data),\n              key,\n              \"data-index\": index,\n              \"data-known-size\": item.size,\n              \"data-item-index\": item.index,\n              \"data-item-group-index\": item.groupIndex,\n              style: horizontalDirection ? HORIZONTAL_ITEM_STYLE : ITEM_STYLE$1\n            },\n            hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context)\n          );\n        }\n      })\n    }\n  );\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst horizontalScrollerStyle = {\n  outline: \"none\",\n  overflowX: \"auto\",\n  position: \"relative\"\n};\nconst viewportStyle = (alignToBottom) => ({\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0,\n  ...alignToBottom ? { display: \"flex\", flexDirection: \"column\" } : {}\n});\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return { context };\n}\nfunction itemPropIfNotDomElement(element, item) {\n  return { item: typeof element === \"string\" ? void 0 : item };\n}\nconst Header$1 = /* @__PURE__ */ React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const HeaderFooterTag = useEmitterValue$2(\"HeaderFooterTag\");\n  const ref = useSize(\n    React.useMemo(() => (el) => headerHeight(correctItemSize(el, \"height\")), [headerHeight]),\n    true,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? /* @__PURE__ */ jsx(HeaderFooterTag, { ref, children: /* @__PURE__ */ jsx(Header2, { ...contextPropIfNotDomElement(Header2, context) }) }) : null;\n});\nconst Footer$1 = /* @__PURE__ */ React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const HeaderFooterTag = useEmitterValue$2(\"HeaderFooterTag\");\n  const ref = useSize(\n    React.useMemo(() => (el) => footerHeight(correctItemSize(el, \"height\")), [footerHeight]),\n    true,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? /* @__PURE__ */ jsx(HeaderFooterTag, { ref, children: /* @__PURE__ */ jsx(Footer2, { ...contextPropIfNotDomElement(Footer2, context) }) }) : null;\n});\nfunction buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const horizontalDirection = useEmitterValue2(\"horizontalDirection\") || false;\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      scrollerRefCallback,\n      void 0,\n      horizontalDirection\n    );\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    const defaultStyle = horizontalDirection ? horizontalScrollerStyle : scrollerStyle;\n    return /* @__PURE__ */ jsx(\n      ScrollerComponent,\n      {\n        ref: scrollerRef,\n        style: { ...defaultStyle, ...style },\n        \"data-testid\": \"virtuoso-scroller\",\n        \"data-virtuoso-scroller\": true,\n        tabIndex: 0,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context),\n        children\n      }\n    );\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoWindowScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      noop,\n      customScrollParent\n    );\n    useIsomorphicLayoutEffect(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return /* @__PURE__ */ jsx(\n      ScrollerComponent,\n      {\n        style: { position: \"relative\", ...style, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },\n        \"data-virtuoso-scroller\": true,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context),\n        children\n      }\n    );\n  });\n  return Scroller2;\n}\nconst Viewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  const horizontalDirection = useEmitterValue$2(\"horizontalDirection\");\n  const viewportSizeCallbackMemo = React.useMemo(\n    () => compose(viewportHeight, (el) => correctItemSize(el, horizontalDirection ? \"width\" : \"height\")),\n    [viewportHeight, horizontalDirection]\n  );\n  const viewportRef = useSize(viewportSizeCallbackMemo, true, useEmitterValue$2(\"skipAnimationFrameInResizeObserver\"));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ jsx(\"div\", { style: viewportStyle(alignToBottom), ref: viewportRef, \"data-viewport-type\": \"element\", children });\n};\nconst WindowViewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(\n    windowViewportRect,\n    customScrollParent,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ jsx(\"div\", { ref: viewportRef, style: viewportStyle(alignToBottom), \"data-viewport-type\": \"window\", children });\n};\nconst TopItemListContainer = ({ children }) => {\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\") || \"div\";\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = { ...topItemListStyle, marginTop: `${headerHeight}px` };\n  const context = useEmitterValue$2(\"context\");\n  return /* @__PURE__ */ jsx(TopItemList, { style, ...contextPropIfNotDomElement(TopItemList, context), children });\n};\nconst ListRoot = /* @__PURE__ */ React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */ jsxs(TheScroller, { ...props, children: [\n    showTopList && /* @__PURE__ */ jsx(TopItemListContainer, { children: /* @__PURE__ */ jsx(Items$1, { showTopList: true }) }),\n    /* @__PURE__ */ jsxs(TheViewport, { children: [\n      /* @__PURE__ */ jsx(Header$1, {}),\n      /* @__PURE__ */ jsx(Items$1, {}),\n      /* @__PURE__ */ jsx(Footer$1, {})\n    ] })\n  ] });\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$2,\n  {\n    required: {},\n    optional: {\n      restoreStateFrom: \"restoreStateFrom\",\n      context: \"context\",\n      followOutput: \"followOutput\",\n      itemContent: \"itemContent\",\n      groupContent: \"groupContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      groupCounts: \"groupCounts\",\n      topItemCount: \"topItemCount\",\n      firstItemIndex: \"firstItemIndex\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"HeaderFooterTag\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\",\n      horizontalDirection: \"horizontalDirection\",\n      skipAnimationFrameInResizeObserver: \"skipAnimationFrameInResizeObserver\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      autoscrollToBottom: \"autoscrollToBottom\",\n      getState: \"getState\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  ListRoot\n);\nconst Scroller$2 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{ index: 0 }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst { round, ceil, floor, min, max } = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({ length: endIndex - startIndex + 1 }).map((_, i) => {\n    const dataItem = data === null ? null : data[i + startIndex];\n    return { index: i + startIndex, data: dataItem };\n  });\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */ system(\n  ([\n    { overscan, visibleRange, listBoundary, increaseViewportBy },\n    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },\n    stateFlags,\n    scrollSeek,\n    { propsReady, didMount },\n    { windowViewportRect, useWindowScroll, customScrollParent, windowScrollContainerState, windowScrollTo },\n    log\n  ]) => {\n    const totalCount = statefulStream(0);\n    const initialItemCount = statefulStream(0);\n    const gridState = statefulStream(INITIAL_GRID_STATE);\n    const viewportDimensions = statefulStream({ height: 0, width: 0 });\n    const itemDimensions = statefulStream({ height: 0, width: 0 });\n    const scrollToIndex = stream();\n    const scrollHeight = stream();\n    const deviation = statefulStream(0);\n    const data = statefulStream(null);\n    const gap = statefulStream({ row: 0, column: 0 });\n    const stateChanged = stream();\n    const restoreStateFrom = stream();\n    const stateRestoreInProgress = statefulStream(false);\n    const initialTopMostItemIndex = statefulStream(0);\n    const scrolledToInitialItem = statefulStream(true);\n    const scrollScheduled = statefulStream(false);\n    const horizontalDirection = statefulStream(false);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location)\n      ),\n      () => {\n        publish(scrolledToInitialItem, false);\n      }\n    );\n    subscribe(\n      pipe(\n        combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled),\n        filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2, , scrollScheduled2]) => {\n          return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;\n        })\n      ),\n      ([, , , , initialTopMostItemIndex2]) => {\n        publish(scrollScheduled, true);\n        skipFrames(1, () => {\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n        handleNext(pipe(scrollTop), () => {\n          publish(listBoundary, [0, 0]);\n          publish(scrolledToInitialItem, true);\n        });\n      }\n    );\n    connect(\n      pipe(\n        restoreStateFrom,\n        filter((value) => value !== void 0 && value !== null && value.scrollTop > 0),\n        mapTo(0)\n      ),\n      initialItemCount\n    );\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(restoreStateFrom),\n        filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)\n      ),\n      ([, snapshot]) => {\n        if (!snapshot) {\n          return;\n        }\n        publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);\n        publish(gap, snapshot.gap);\n        if (snapshot.scrollTop > 0) {\n          publish(stateRestoreInProgress, true);\n          handleNext(pipe(scrollTop, skip(1)), (_value) => {\n            publish(stateRestoreInProgress, false);\n          });\n          publish(scrollTo, { top: snapshot.scrollTop });\n        }\n      }\n    );\n    connect(\n      pipe(\n        viewportDimensions,\n        map(({ height }) => height)\n      ),\n      viewportHeight\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(viewportDimensions, dimensionComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row),\n          duc(scrollTop)\n        ),\n        map(([viewport, item, gap2, scrollTop2]) => ({\n          viewport,\n          item,\n          gap: gap2,\n          scrollTop: scrollTop2\n        }))\n      ),\n      stateChanged\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(totalCount),\n          visibleRange,\n          duc(gap, gapComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(viewportDimensions, dimensionComparator),\n          duc(data),\n          duc(initialItemCount),\n          duc(stateRestoreInProgress),\n          duc(scrolledToInitialItem),\n          duc(initialTopMostItemIndex)\n        ),\n        filter(([, , , , , , , stateRestoreInProgress2]) => {\n          return !stateRestoreInProgress2;\n        }),\n        map(\n          ([\n            totalCount2,\n            [startOffset, endOffset],\n            gap2,\n            item,\n            viewport,\n            data2,\n            initialItemCount2,\n            ,\n            scrolledToInitialItem2,\n            initialTopMostItemIndex2\n          ]) => {\n            const { row: rowGap, column: columnGap } = gap2;\n            const { height: itemHeight, width: itemWidth } = item;\n            const { width: viewportWidth } = viewport;\n            if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {\n              return INITIAL_GRID_STATE;\n            }\n            if (itemWidth === 0) {\n              const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);\n              const endIndex2 = startIndex2 + Math.max(initialItemCount2 - 1, 0);\n              return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));\n            }\n            const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n            let startIndex;\n            let endIndex;\n            if (!scrolledToInitialItem2) {\n              startIndex = 0;\n              endIndex = -1;\n            } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {\n              startIndex = 0;\n              endIndex = initialItemCount2 - 1;\n            } else {\n              startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n              endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n              endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n              startIndex = min(endIndex, max(0, startIndex));\n            }\n            const items = buildItems(startIndex, endIndex, data2);\n            const { top, bottom } = gridLayout(viewport, gap2, item, items);\n            const rowCount = ceil(totalCount2 / perRow);\n            const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n            const offsetBottom = totalHeight - bottom;\n            return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth };\n          }\n        )\n      ),\n      gridState\n    );\n    connect(\n      pipe(\n        data,\n        filter((data2) => data2 !== null),\n        map((data2) => data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        combineLatest(viewportDimensions, itemDimensions, gridState, gap),\n        filter(([viewportDimensions2, itemDimensions2, { items }]) => {\n          return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;\n        }),\n        map(([viewportDimensions2, itemDimensions2, { items }, gap2]) => {\n          const { top, bottom } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);\n          return [top, bottom];\n        }),\n        distinctUntilChanged(tupleComparator)\n      ),\n      listBoundary\n    );\n    const hasScrolled = statefulStream(false);\n    connect(\n      pipe(\n        scrollTop,\n        withLatestFrom(hasScrolled),\n        map(([scrollTop2, hasScrolled2]) => {\n          return hasScrolled2 || scrollTop2 !== 0;\n        })\n      ),\n      hasScrolled\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        combineLatest(gridState, totalCount),\n        filter(([{ items }]) => items.length > 0),\n        withLatestFrom(hasScrolled),\n        filter(([[gridState2, totalCount2], hasScrolled2]) => {\n          const lastIndex = gridState2.items[gridState2.items.length - 1].index;\n          const isLastItemRendered = lastIndex === totalCount2 - 1;\n          if (hasScrolled2) return isLastItemRendered;\n          const isFullyRendered = gridState2.bottom > 0 && gridState2.itemHeight > 0 && gridState2.offsetBottom === 0 && gridState2.items.length === totalCount2;\n          return isFullyRendered && isLastItemRendered;\n        }),\n        map(([[, totalCount2]]) => {\n          return totalCount2 - 1;\n        }),\n        distinctUntilChanged()\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => {\n          return items.length > 0 && items[0].index === 0;\n        }),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(0),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        withLatestFrom(stateRestoreInProgress),\n        filter(([{ items }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2),\n        map(([{ items }]) => {\n          return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator),\n        throttleTime(0)\n      )\n    );\n    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap),\n        map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {\n          const normalLocation = normalizeIndexLocation(location);\n          const { align, behavior, offset } = normalLocation;\n          let index = normalLocation.index;\n          if (index === \"LAST\") {\n            index = totalCount2 - 1;\n          }\n          index = max(0, index, min(totalCount2 - 1, index));\n          let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);\n          if (align === \"end\") {\n            top = round(top - viewportDimensions2.height + itemDimensions2.height);\n          } else if (align === \"center\") {\n            top = round(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);\n          }\n          if (offset) {\n            top += offset;\n          }\n          return { top, behavior };\n        })\n      ),\n      scrollTo\n    );\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        gridState,\n        map((gridState2) => {\n          return gridState2.offsetBottom + gridState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(\n      pipe(\n        windowViewportRect,\n        map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))\n      ),\n      viewportDimensions\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      viewportDimensions,\n      itemDimensions,\n      scrollTop,\n      scrollHeight,\n      overscan,\n      increaseViewportBy,\n      scrollBy,\n      scrollTo,\n      scrollToIndex,\n      smoothScrollTargetReached,\n      windowViewportRect,\n      windowScrollTo,\n      useWindowScroll,\n      customScrollParent,\n      windowScrollContainerState,\n      deviation,\n      scrollContainerState,\n      footerHeight,\n      headerHeight,\n      initialItemCount,\n      gap,\n      restoreStateFrom,\n      ...scrollSeek,\n      initialTopMostItemIndex,\n      horizontalDirection,\n      // output\n      gridState,\n      totalListHeight,\n      ...stateFlags,\n      startReached,\n      endReached,\n      rangeChanged,\n      stateChanged,\n      propsReady,\n      stateRestoreInProgress,\n      ...log\n    };\n  },\n  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)\n);\nfunction gridLayout(viewport, gap, item, items) {\n  const { height: itemHeight } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return { top: 0, bottom: 0 };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return { top, bottom };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  const readyStateChanged = statefulStream(false);\n  const reportReadyState = statefulStream(false);\n  connect(duc(reportReadyState), readyStateChanged);\n  return {\n    readyStateChanged,\n    reportReadyState,\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {\n  return { ...gridSystem2, ...gridComponentPropsSystem2 };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */ React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const stateRestoreInProgress = useEmitterValue$1(\"stateRestoreInProgress\");\n  const reportReadyState = usePublisher$1(\"reportReadyState\");\n  const listRef = useSize(\n    React.useMemo(\n      () => (el) => {\n        const scrollHeight = el.parentElement.parentElement.scrollHeight;\n        scrollHeightCallback(scrollHeight);\n        const firstItem = el.firstChild;\n        if (firstItem) {\n          const { width, height } = firstItem.getBoundingClientRect();\n          itemDimensions({ width, height });\n        }\n        gridGap({\n          row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n          column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n        });\n      },\n      [scrollHeightCallback, itemDimensions, gridGap, log]\n    ),\n    true,\n    false\n  );\n  useIsomorphicLayoutEffect(() => {\n    if (gridState.itemHeight > 0 && gridState.itemWidth > 0) {\n      reportReadyState(true);\n    }\n  }, [gridState]);\n  if (stateRestoreInProgress) {\n    return null;\n  }\n  return /* @__PURE__ */ jsx(\n    ListComponent,\n    {\n      ref: listRef,\n      className: listClassName,\n      ...contextPropIfNotDomElement(ListComponent, context),\n      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },\n      \"data-testid\": \"virtuoso-item-list\",\n      children: gridState.items.map((item) => {\n        const key = computeItemKey(item.index, item.data, context);\n        return isSeeking ? /* @__PURE__ */ jsx(\n          ScrollSeekPlaceholder,\n          {\n            ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n            index: item.index,\n            height: gridState.itemHeight,\n            width: gridState.itemWidth\n          },\n          key\n        ) : /* @__PURE__ */ createElement(\n          ItemComponent,\n          {\n            ...contextPropIfNotDomElement(ItemComponent, context),\n            className: itemClassName,\n            \"data-index\": item.index,\n            key\n          },\n          itemContent(item.index, item.data, context)\n        );\n      })\n    }\n  );\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const HeaderFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(\n    React.useMemo(() => (el) => headerHeight(correctItemSize(el, \"height\")), [headerHeight]),\n    true,\n    false\n  );\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? /* @__PURE__ */ jsx(HeaderFooterTag, { ref, children: /* @__PURE__ */ jsx(Header2, { ...contextPropIfNotDomElement(Header2, context) }) }) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const HeaderFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(\n    React.useMemo(() => (el) => footerHeight(correctItemSize(el, \"height\")), [footerHeight]),\n    true,\n    false\n  );\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? /* @__PURE__ */ jsx(HeaderFooterTag, { ref, children: /* @__PURE__ */ jsx(Footer2, { ...contextPropIfNotDomElement(Footer2, context) }) }) : null;\n});\nconst Viewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize(\n    React.useMemo(\n      () => (el) => {\n        viewportDimensions(el.getBoundingClientRect());\n      },\n      [viewportDimensions]\n    ),\n    true,\n    false\n  );\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({ height: ctx.viewportHeight, width: ctx.viewportWidth });\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */ jsx(\"div\", { style: viewportStyle(false), ref: viewportRef, children });\n};\nconst WindowViewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, false);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: ctx.viewportWidth });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */ jsx(\"div\", { ref: viewportRef, style: viewportStyle(false), children });\n};\nconst GridRoot = /* @__PURE__ */ React.memo(function GridRoot2({ ...props }) {\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */ jsx(TheScroller, { ...props, children: /* @__PURE__ */ jsxs(TheViewport, { children: [\n    /* @__PURE__ */ jsx(Header, {}),\n    /* @__PURE__ */ jsx(GridItems, {}),\n    /* @__PURE__ */ jsx(Footer, {})\n  ] }) });\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$1,\n  {\n    optional: {\n      context: \"context\",\n      totalCount: \"totalCount\",\n      overscan: \"overscan\",\n      itemContent: \"itemContent\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      listClassName: \"listClassName\",\n      itemClassName: \"itemClassName\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\",\n      restoreStateFrom: \"restoreStateFrom\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      increaseViewportBy: \"increaseViewportBy\"\n    },\n    methods: {\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      stateChanged: \"stateChanged\",\n      readyStateChanged: \"readyStateChanged\"\n    }\n  },\n  GridRoot\n);\nconst Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nconst WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => /* @__PURE__ */ jsxs(\"td\", { children: [\n    \"Item $\",\n    index\n  ] }));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({ height }) => /* @__PURE__ */ jsx(\"tr\", { children: /* @__PURE__ */ jsx(\"td\", { style: { height } }) });\nconst DefaultFillerRow = ({ height }) => /* @__PURE__ */ jsx(\"tr\", { children: /* @__PURE__ */ jsx(\"td\", { style: { height, padding: 0, border: 0 } }) });\nconst ITEM_STYLE = { overflowAnchor: \"none\" };\nconst Items = /* @__PURE__ */ React.memo(function VirtuosoItems2({ showTopList = false }) {\n  const listState = useEmitterValue(\"listState\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const context = useEmitterValue(\"context\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const fixedHeaderHeight = useEmitterValue(\"fixedHeaderHeight\");\n  const itemContent = useEmitterValue(\"itemContent\");\n  const topItemOffsets = (showTopList ? listState.topItems : []).reduce((acc, item, index) => {\n    if (index === 0) {\n      acc.push(item.size);\n    } else {\n      acc.push(acc[index - 1] + item.size);\n    }\n    return acc;\n  }, []);\n  const items = (showTopList ? listState.topItems : listState.items).map((item) => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    const offsetTop = showTopList ? index === 0 ? 0 : topItemOffsets[index - 1] : 0;\n    if (isSeeking) {\n      return /* @__PURE__ */ createElement(\n        ScrollSeekPlaceholder,\n        {\n          ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n          key,\n          index: item.index,\n          height: item.size,\n          type: item.type || \"item\"\n        }\n      );\n    }\n    return /* @__PURE__ */ createElement(\n      TableRowComponent,\n      {\n        ...contextPropIfNotDomElement(TableRowComponent, context),\n        ...itemPropIfNotDomElement(TableRowComponent, item.data),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        style: showTopList ? { overflowAnchor: \"none\", position: \"sticky\", zIndex: 2, top: fixedHeaderHeight + offsetTop } : ITEM_STYLE\n      },\n      itemContent(item.index, item.data, context)\n    );\n  });\n  return /* @__PURE__ */ jsx(Fragment, { children: items });\n});\nconst TableBody = /* @__PURE__ */ React.memo(function TableVirtuosoBody() {\n  const listState = useEmitterValue(\"listState\");\n  const showTopList = useEmitterValue(\"topItemsIndexes\").length > 0;\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const { callbackRef, ref } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    scrollContainerStateCallback,\n    log,\n    void 0,\n    customScrollParent,\n    false,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", (value) => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return /* @__PURE__ */ jsx(EmptyPlaceholder, { ...contextPropIfNotDomElement(EmptyPlaceholder, context) });\n  }\n  const topItemsSize = (showTopList ? listState.topItems : []).reduce((acc, item) => acc + item.size, 0);\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation - topItemsSize;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ jsx(FillerRow, { height: paddingTop, context }, \"padding-top\") : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ jsx(FillerRow, { height: paddingBottom, context }, \"padding-bottom\") : null;\n  return /* @__PURE__ */ jsxs(TableBodyComponent, { ref: callbackRef, \"data-testid\": \"virtuoso-item-list\", ...contextPropIfNotDomElement(TableBodyComponent, context), children: [\n    paddingTopEl,\n    showTopList && /* @__PURE__ */ jsx(Items, { showTopList: true }),\n    /* @__PURE__ */ jsx(Items, {}),\n    paddingBottomEl\n  ] });\n});\nconst Viewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(\n    React.useMemo(() => compose(viewportHeight, (el) => correctItemSize(el, \"height\")), [viewportHeight]),\n    true,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ jsx(\"div\", { style: viewportStyle(false), ref: viewportRef, \"data-viewport-type\": \"element\", children });\n};\nconst WindowViewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(\n    windowViewportRect,\n    customScrollParent,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ jsx(\"div\", { ref: viewportRef, style: viewportStyle(false), \"data-viewport-type\": \"window\", children });\n};\nconst TableRoot = /* @__PURE__ */ React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(\n    React.useMemo(() => compose(fixedHeaderHeight, (el) => correctItemSize(el, \"height\")), [fixedHeaderHeight]),\n    true,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  const tfootRef = useSize(\n    React.useMemo(() => compose(fixedFooterHeight, (el) => correctItemSize(el, \"height\")), [fixedFooterHeight]),\n    true,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? /* @__PURE__ */ jsx(\n    TheTHead,\n    {\n      style: { zIndex: 2, position: \"sticky\", top: 0 },\n      ref: theadRef,\n      ...contextPropIfNotDomElement(TheTHead, context),\n      children: fixedHeaderContent()\n    },\n    \"TableHead\"\n  ) : null;\n  const theFoot = fixedFooterContent ? /* @__PURE__ */ jsx(\n    TheTFoot,\n    {\n      style: { zIndex: 1, position: \"sticky\", bottom: 0 },\n      ref: tfootRef,\n      ...contextPropIfNotDomElement(TheTFoot, context),\n      children: fixedFooterContent()\n    },\n    \"TableFoot\"\n  ) : null;\n  return /* @__PURE__ */ jsx(TheScroller, { ...props, children: /* @__PURE__ */ jsx(TheViewport, { children: /* @__PURE__ */ jsxs(TheTable, { style: { borderSpacing: 0, overflowAnchor: \"none\" }, ...contextPropIfNotDomElement(TheTable, context), children: [\n    theHead,\n    /* @__PURE__ */ jsx(TableBody, {}, \"TableBody\"),\n    theFoot\n  ] }) }) });\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem,\n  {\n    required: {},\n    optional: {\n      restoreStateFrom: \"restoreStateFrom\",\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedFooterContent: \"fixedFooterContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      getState: \"getState\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  TableRoot\n);\nconst Scroller = /* @__PURE__ */ buildScroller({ usePublisher, useEmitterValue, useEmitter });\nconst WindowScroller = /* @__PURE__ */ buildWindowScroller({ usePublisher, useEmitterValue, useEmitter });\nconst TableVirtuoso = Table;\nexport {\n  GroupedVirtuoso,\n  LogLevel,\n  TableVirtuoso,\n  Virtuoso,\n  VirtuosoGrid,\n  VirtuosoGridMockContext,\n  VirtuosoMockContext\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}